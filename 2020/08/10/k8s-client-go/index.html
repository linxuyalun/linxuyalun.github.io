<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Alan&#39;s Blog">
    <meta name="keyword"  content="">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
        Kubernetes 源码剖析 -- Client-go - Alan&#39;s Blog
        
    </title>

    <!-- Custom CSS -->
    
<link rel="stylesheet" href="/css/aircloud.css">

    
<link rel="stylesheet" href="/css/gitment.css">

    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_pl6z7sid89qkt9.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
<meta name="generator" content="Hexo 4.2.0"></head>

<body>

<div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i> 激水之疾，至于漂石者，势也。 </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar ">
            <img src="/img/avatar.jpg" />
        </div>
        <div class="name">
            <i>Lin Hsu Yalun</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li >
                <a href="/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>主页</span>
                </a>
            </li>
            <li >
                <a href="/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>标签</span>
                </a>
            </li>
            <li >
                <a href="/archives">
                    <i class="iconfont icon-guidang2"></i>
                    <span>存档</span>
                </a>
            </li>
            <li >
                <a href="/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>关于</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#源码结构"><span class="toc-text">源码结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Client-客户端对象"><span class="toc-text">Client 客户端对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Kubeconfig"><span class="toc-text">Kubeconfig</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RESTClient"><span class="toc-text">RESTClient</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ClientSet"><span class="toc-text">ClientSet</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DynamicClient"><span class="toc-text">DynamicClient</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DiscoveryClient"><span class="toc-text">DiscoveryClient</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Informer-机制"><span class="toc-text">Informer 机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Informer-机制架构设计"><span class="toc-text">Informer 机制架构设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Reflector"><span class="toc-text">Reflector</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DeltaFIFO"><span class="toc-text">DeltaFIFO</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#生产者方法"><span class="toc-text">生产者方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#消费者方法"><span class="toc-text">消费者方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Resync-机制"><span class="toc-text">Resync 机制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Indexer"><span class="toc-text">Indexer</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ThreadSafeStore"><span class="toc-text">ThreadSafeStore</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Indexer-索引器"><span class="toc-text">Indexer 索引器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Indexer-索引器核心实现"><span class="toc-text">Indexer 索引器核心实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WorkQueue"><span class="toc-text">WorkQueue</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#FIFO-队列"><span class="toc-text">FIFO 队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#延迟队列"><span class="toc-text">延迟队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#限速队列"><span class="toc-text">限速队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#BucketRateLimiter"><span class="toc-text">BucketRateLimiter</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ItemExponentialFailureRateLimiter"><span class="toc-text">ItemExponentialFailureRateLimiter</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ItemFastSlowRateLimiter"><span class="toc-text">ItemFastSlowRateLimiter</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MaxOfRateLimiter"><span class="toc-text">MaxOfRateLimiter</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#限速队列实现"><span class="toc-text">限速队列实现</span></a></li></ol></li></ol></li></ol>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input"/>
            <span id="begin-search">搜索</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>

        <div class="index-about-mobile">
            <i> 激水之疾，至于漂石者，势也。 </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        


<div class="post-container">
    <div class="post-title">
        Kubernetes 源码剖析 -- Client-go
    </div>

    <div class="post-meta">
        <span class="attr">发布于：<span>2020-08-10 15:00:00</span></span>
        
        <span class="attr">标签：/
        
        <a class="tag" href="/tags/#术" title="术">术</a>
        <span>/</span>
        
        
        </span>
        <span class="attr">访问：<span id="busuanzi_value_page_pv"></span>
</span>
</span>
    </div>
    <div class="post-content ">
        <figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Kubernetes</span> <span class="string">Version: release-1.14</span></span><br><span class="line"><span class="attr">Reference</span>: <span class="string">Kubernetes 源码剖析</span></span><br><span class="line"><span class="attr">LastUpdate</span>: <span class="string">2020.08.16</span></span><br></pre></td></tr></table></figure>

<h2 id="源码结构"><a href="#源码结构" class="headerlink" title="源码结构"></a>源码结构</h2><table>
<thead>
<tr>
<th>目录名</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>discovery</td>
<td>discovery client，对 rest 客户端的进一步封装，用于发现 apiserver 所支持的能力和信息</td>
</tr>
<tr>
<td>dynamic</td>
<td>dynamic client ，对 rest 客户端的进一步封装，动态客户端，面向处理 CRD</td>
</tr>
<tr>
<td>examples</td>
<td>例子，比如对 deployment 创建、修改，如何选主，workqueue 如何使用等等</td>
</tr>
<tr>
<td>informers</td>
<td>这就是 client-go 中非常有名的 informer 机制的核心代码</td>
</tr>
<tr>
<td>kubernetes</td>
<td>clientset 的代码，对 rest 客户端的封装，提供复杂的内置资源访问和管理能力</td>
</tr>
<tr>
<td>listers</td>
<td>为每个 k8s 资源提供 lister 功能，提供了只读缓存功能</td>
</tr>
<tr>
<td>plugin</td>
<td>提供云服务商授权插件</td>
</tr>
<tr>
<td>pkg</td>
<td>主要是一些功能函数，比如版本函数</td>
</tr>
<tr>
<td>rest</td>
<td>这是最基础的 client，其它的 client 都是基于此派生的</td>
</tr>
<tr>
<td>scale</td>
<td>scale client 的代码，对 rest 客户端的进一步封装，用于扩容和缩容</td>
</tr>
<tr>
<td>tools</td>
<td>工具函数库，主要是和 k8s 相关的工具函数；提供 Client 查询和缓存</td>
</tr>
<tr>
<td>util</td>
<td>通用的一些工具函数，比如 WorkQueue 工作队列，Certificate 证书管理</td>
</tr>
<tr>
<td>transport</td>
<td>提供安全 tcp 链接</td>
</tr>
</tbody></table>
<h2 id="Client-客户端对象"><a href="#Client-客户端对象" class="headerlink" title="Client 客户端对象"></a>Client 客户端对象</h2><p>首先 Rest 是最基础的客户端，RESTCLient 对 HTTP Request 进行了封装，实现 RESTful 的API 风格。ClientSet，DynamicClient 以及 DiscoveryClient 客户端都是基于 RESTClient 实现的。</p>
<ul>
<li>ClientSet 在 RESTClient 基础上封装了 Resource 和 Version 的管理方法，一个 Resource 可以理解为一个客户端，ClientSet 是多个客户端的集合，ClientSet 只能处理 K8s 内置资源；</li>
<li>DynamicClient 可以处理 K8s 所有资源对象，包括内置资源与 CRD 自定义资源；</li>
<li>DiscoveryClient 用于发现 kube-apiserver 所支持的资源组，资源版本和资源信息（Group，Version 以及 Resources）。</li>
</ul>
<p>要使用以上四种客户端，<strong>需要先通过 kubeconfig 连接到指定的 Kubernetes API Server</strong>（确定权限粒度）。</p>
<p>看下面一个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Code from： https://jeremy-boo.github.io/post/client-go/</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"flag"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"path/filepath"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">    metav1 <span class="string">"k8s.io/apimachinery/pkg/apis/meta/v1"</span></span><br><span class="line">    <span class="string">"k8s.io/client-go/kubernetes"</span></span><br><span class="line">    <span class="string">"k8s.io/client-go/tools/clientcmd"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> kubeconfig *<span class="keyword">string</span></span><br><span class="line">  <span class="keyword">if</span> home := homeDir(); home != <span class="string">""</span> &#123;</span><br><span class="line">        kubeconfig = flag.String(<span class="string">"kubeconfig"</span>, filepath.Join(home, <span class="string">".kube"</span>, <span class="string">"config"</span>), <span class="string">"(optional) absolute path to the kubeconfig file"</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        kubeconfig = flag.String(<span class="string">"kubeconfig"</span>, <span class="string">""</span>, <span class="string">"absolute path to the kubeconfig file"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  flag.Parse()</span><br><span class="line">  <span class="comment">// uses the current context in kubeconfig</span></span><br><span class="line">  config, err := clientcmd.BuildConfigFromFlags(<span class="string">""</span>, *kubeconfig)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(err.Error())</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// creates the clientset</span></span><br><span class="line">  clientset, err := kubernetes.NewForConfig(config)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(err.Error())</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// get pods list</span></span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">      pods, err := clientset.CoreV1().Pods(<span class="string">""</span>).List(metav1.ListOptions&#123;&#125;)</span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">          <span class="built_in">panic</span>(err.Error())</span><br><span class="line">      &#125;</span><br><span class="line">      fmt.Printf(<span class="string">"There are %d pods in the cluster\n"</span>, <span class="built_in">len</span>(pods.Items))</span><br><span class="line">      time.Sleep(<span class="number">10</span> * time.Second)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">homeDir</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> h := os.Getenv(<span class="string">"HOME"</span>); h != <span class="string">""</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> h</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> os.Getenv(<span class="string">"USERPROFILE"</span>) <span class="comment">// windows</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Kubeconfig"><a href="#Kubeconfig" class="headerlink" title="Kubeconfig"></a>Kubeconfig</h3><p>以上面这个例子为例，读取 Kubeconfig 配置文件的关键代码在于 <code>clientcmd.BuildConfigFromFlags</code>，它会读取配置信息并且实例化一个 res.Config 对象，由于 kubeconfig 会有多个 kube-apiserver 集群的配置信息，因此它需要能够合并多个配置信息，该过程由 Load 函数完成。分为<strong>加载 kubeconfig 文件</strong>和<strong>合并 kubeconfig 配置</strong>信息两步：</p>
<ol>
<li>加载 kubeconfig 文件；</li>
</ol>
<p><code>vendor/k8s.io/client-go/tools/clientcmd/loader.go</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rules *ClientConfigLoadingRules)</span> <span class="title">Load</span><span class="params">()</span> <span class="params">(*clientcmdapi.Config, error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">	kubeConfigFiles := []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Make sure a file we were explicitly told to use exists</span></span><br><span class="line">  <span class="comment">// ExplicitPath 为显式地址，用于合并</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(rules.ExplicitPath) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> _, err := os.Stat(rules.ExplicitPath); os.IsNotExist(err) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">		kubeConfigFiles = <span class="built_in">append</span>(kubeConfigFiles, rules.ExplicitPath)</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Precedence 是个 []string</span></span><br><span class="line">		kubeConfigFiles = <span class="built_in">append</span>(kubeConfigFiles, rules.Precedence...)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	kubeconfigs := []*clientcmdapi.Config&#123;&#125;</span><br><span class="line">	<span class="comment">// read and cache the config files so that we only look at them once</span></span><br><span class="line">	<span class="keyword">for</span> _, filename := <span class="keyword">range</span> kubeConfigFiles &#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// LoadFromFile takes a filename and deserializes the contents into Config object</span></span><br><span class="line">    <span class="comment">// 把变量从内存中取出变成可存储的传输对象成为序列化，反之从可存储的传输对象变成内存对象为反序列化；</span></span><br><span class="line">    <span class="comment">// 这里就是读取文件，转换成一个 config 对象</span></span><br><span class="line">		config, err := LoadFromFile(filename)</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">		kubeconfigs = <span class="built_in">append</span>(kubeconfigs, config)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ... merge 部分代码</span></span><br><span class="line">	<span class="keyword">return</span> config, utilerrors.NewAggregate(errlist)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>合并 kubeconfig 配置</li>
</ol>
<p>这部分的合并有一个优先级的关系，上面 Load 函数的 merge 部分是：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// first merge all of our maps</span></span><br><span class="line">mapConfig := clientcmdapi.NewConfig()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, kubeconfig := <span class="keyword">range</span> kubeconfigs &#123;</span><br><span class="line">	mergo.MergeWithOverwrite(mapConfig, kubeconfig)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// merge all of the struct values in the reverse order so that priority is given correctly</span></span><br><span class="line"><span class="comment">// errors are not added to the list the second time</span></span><br><span class="line">nonMapConfig := clientcmdapi.NewConfig()</span><br><span class="line"><span class="keyword">for</span> i := <span class="built_in">len</span>(kubeconfigs) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">	kubeconfig := kubeconfigs[i]</span><br><span class="line">	mergo.MergeWithOverwrite(nonMapConfig, kubeconfig)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// since values are overwritten, but maps values are not, we can merge the non-map config on top of the map config and</span></span><br><span class="line"><span class="comment">// get the values we expect.</span></span><br><span class="line">config := clientcmdapi.NewConfig()</span><br><span class="line">mergo.MergeWithOverwrite(config, mapConfig)</span><br><span class="line">mergo.MergeWithOverwrite(config, nonMapConfig)</span><br></pre></td></tr></table></figure>

<p><a href="https://pkg.go.dev/github.com/imdario/mergo?tab=doc#MergeWithOverwrite" target="_blank" rel="noopener">MergeWithOverWrite</a> 是来自 <a href="https://pkg.go.dev/github.com/imdario/mergo?tab=doc" target="_blank" rel="noopener">mergo</a> 包的一个函数，第一个参数为 src，第二个参数为 dst，merge 后的结构例子如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">src:      T&#123;X: &quot;two&quot;, Z:&#123;A: &quot;three&quot;, B: 4&#125;&#125;</span><br><span class="line">dst:      T&#123;X: &quot;one&quot;, Y: 5, Z:&#123;A: &quot;four&quot;, B: 6&#125;&#125;</span><br><span class="line">result:   T&#123;X: &quot;two&quot;, Y: 5, Z:&#123;A: &quot;three&quot;, B: 4&#125;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RESTClient"><a href="#RESTClient" class="headerlink" title="RESTClient"></a>RESTClient</h3><p>一个使用 RESTClient 的例子见书本 134页。使用的关键代码为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// result := &amp;corev1.PodList&#123;&#125;</span></span><br><span class="line">restClient.Get().Namespaces(<span class="string">"default"</span>).Resources(<span class="string">"pods"</span>).VersionParams(&amp;metav1.ListOptions&#123;Limit: <span class="number">500</span>&#125;, scheme.ParamterCodec).Do().Into(result)</span><br></pre></td></tr></table></figure>

<p>其中，restClient 为通过 kubeconfig 文件生成的 Client 对象，Get 方法封装了 HTTP get 请求，VersionParams 将一些查询选项添加到请求参数中，通过 Do 函数执行请求，并将 kube-apiserver 返回的结果（结果是一个 Result 对象）解析到 corev1.PodList 对象中。</p>
<p>看下面这个 Do 方法：</p>
<p><code>vendor/k8s.io/client-go/rest/request.go</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Do formats and executes the request. Returns a Result object for easy response</span></span><br><span class="line"><span class="comment">// processing.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Error type:</span></span><br><span class="line"><span class="comment">//  * If the request can't be constructed, or an error happened earlier while building its</span></span><br><span class="line"><span class="comment">//    arguments: *RequestConstructionError</span></span><br><span class="line"><span class="comment">//  * If the server responds with a status: *errors.StatusError or *errors.UnexpectedObjectError</span></span><br><span class="line"><span class="comment">//  * http.Client.Do errors are returned directly.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Request)</span> <span class="title">Do</span><span class="params">()</span> <span class="title">Result</span></span> &#123;</span><br><span class="line">	r.tryThrottle()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> result Result</span><br><span class="line">	err := r.request(<span class="function"><span class="keyword">func</span><span class="params">(req *http.Request, resp *http.Response)</span></span> &#123;</span><br><span class="line">    <span class="comment">// transformResponse 把一个 API response 转化为一个 structured API object</span></span><br><span class="line">		result = r.transformResponse(resp, req)</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> Result&#123;err: err&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，request 方法的实现可以参见 <a href="https://jinrunsen.com/learn-clien-go-request/" target="_blank" rel="noopener">学习 client-go 中 request 函数的实现</a>，写得非常详细了。</p>
<h3 id="ClientSet"><a href="#ClientSet" class="headerlink" title="ClientSet"></a>ClientSet</h3><p>对于 RESTClient 而言，必须指定 Resource 和 Version，ClientSet 在 RESTClient 的基础上封装了 Resource 和 Version，通过函数的方法直接调用，比如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">clientset, err := kubernetes.NewForConfig(config)</span><br><span class="line"><span class="comment">// err handling</span></span><br><span class="line">podClient := clientset.CoreV1().Pods(apiv1.NamespaceDefault)</span><br><span class="line">list, err := podClient.List(metav1.ListOptions&#123;limit: <span class="number">500</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>相比于 RESTClient 的多次调用，<code>CoreV1().Pods(apiv1.NamespaceDefault)</code>  表示对 core 核心资源组的 v1 资源版本下的 Pod 资源对象。而关于 Pod 的操作也是一层封装，比如 List 操作：</p>
<p><code>vendor/k8s.io/client-go/kubernetes/typed/core/v1/pod.go</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *pods)</span> <span class="title">List</span><span class="params">(opts metav1.ListOptions)</span> <span class="params">(result *v1.PodList, err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> timeout time.Duration</span><br><span class="line">	<span class="keyword">if</span> opts.TimeoutSeconds != <span class="literal">nil</span> &#123;</span><br><span class="line">		timeout = time.Duration(*opts.TimeoutSeconds) * time.Second</span><br><span class="line">	&#125;</span><br><span class="line">	result = &amp;v1.PodList&#123;&#125;</span><br><span class="line">  <span class="comment">// 这一步就是调用原来的 RestClient</span></span><br><span class="line">	err = c.client.Get().</span><br><span class="line">		Namespace(c.ns).</span><br><span class="line">		Resource(<span class="string">"pods"</span>).</span><br><span class="line">		VersionedParams(&amp;opts, scheme.ParameterCodec).</span><br><span class="line">		Timeout(timeout).</span><br><span class="line">		Do().</span><br><span class="line">		Into(result)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="DynamicClient"><a href="#DynamicClient" class="headerlink" title="DynamicClient"></a>DynamicClient</h3><p>ClientSet 只能访问 k8s 自带的资源，而 DynamicClient 可以访问 CRD 自定义资源，这因为 ClientSet 预先实现每种 Resource 和 Version，内部的数据都是结构化的。而 DynamicClient 内部实现了 Unstructured，用于处理非结构化数据。</p>
<p>假设获取 List Pod 的操作（PodList），DynamicClient 的处理过程将所有 Resource 转化为 Unstructured 结构类型，进行相应的处理，处理完成后再将 Unstructured 的结构转换成 PodList，整个过程类似于 Go 语言的 interface{} 断言转化过程。而 Unstructured 结构类型是通过 map[string]interface{} 转换的。</p>
<p>⚠️  DynamicClient 不是类型安全，访问 CRD 自定义资源时，操作指针不当可能导致程序崩溃。</p>
<p>如书本第 140 页的例子，关键流程为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dynamicClient, err := dynamic.NewForConfig(config)</span><br><span class="line"><span class="comment">// 资源组，资源版本，资源名称</span></span><br><span class="line">gvr := schema.GroupVersionResource&#123;Version: <span class="string">"v1"</span>, Resource: <span class="string">"pods"</span>&#125;</span><br><span class="line"><span class="comment">// 得到的 Pod 列表是一个 unstructured.UnstructuredList 的指针类型</span></span><br><span class="line">unstructObj, err := dynamicClient.Resource(gvr).NameSpace(apiV1.NamespaceDefault).List(metav1.ListOptions&#123;limit: <span class="number">500</span>&#125;)</span><br><span class="line">podList := &amp;corev1.PodList&#123;&#125;</span><br><span class="line"><span class="comment">// 转换成 PodList 类型</span></span><br><span class="line">err = runtime.DefaultUnstructuredConverter.FromUnstructured(unstructObj.UnstructuredContent(), podList)</span><br><span class="line"><span class="comment">// err handling</span></span><br></pre></td></tr></table></figure>

<h3 id="DiscoveryClient"><a href="#DiscoveryClient" class="headerlink" title="DiscoveryClient"></a>DiscoveryClient</h3><p>DiscoveryClient 用于查看 Kubernetes API Server 所支持的资源组，资源版本和资源信息。</p>
<p>它同样是在 ClientSet 上的一层封装，实际上，kubectl 的api-versions 和 api-resources 的命令就是通过 DiscoveryClient 实现的。</p>
<p>DiscoveryClient 除了可以发现所支持的资源组，版本和信息，还可以将这些内容缓存到本地，从而缓解 Kubenertes API Server 访问的压力，默认存储在 <code>~/.kube/cache</code> 和  <code>~/.kube/http-cache</code> 下。</p>
<p>如书本第 142 页的例子，关键流程为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">discoveryClient, err := discovery.NewDiscoveryForConfig(config)</span><br><span class="line">_, APIResourceList, err := discoveryClient.ServerGroupsAndResources()</span><br><span class="line"><span class="keyword">for</span> _, list := <span class="keyword">range</span> APIResourceList &#123;</span><br><span class="line">  gv, err := schema.ParseGroupVersion(list.GroupVersion)</span><br><span class="line">  <span class="keyword">for</span> _, resource := <span class="keyword">range</span> list.APIResources &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"name: %v, group: %v, version: %v\n"</span>, resource.Name, gv.Group, gv.Version)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>获取 Kubernetes API Server 支持的资源组，资源版本，资源信息。</li>
</ol>
<p>APIServer 对外暴露的是 /api 和 /apis 两个接口；DiscoveryClient 通过访问这两个接口还获取信息，核心实现位于 ServerGroupsAndResources 中的 ServerGroups 方法中：</p>
<p><code>vendor/k8s.io/client-go/discovery/discovery_client.go</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *DiscoveryClient)</span> <span class="title">ServerGroups</span><span class="params">()</span> <span class="params">(apiGroupList *metav1.APIGroupList, err error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// Get the groupVersions exposed at /api</span></span><br><span class="line">	v := &amp;metav1.APIVersions&#123;&#125;</span><br><span class="line">	err = d.restClient.Get().AbsPath(d.LegacyPrefix).Do().Into(v)</span><br><span class="line">	<span class="comment">// error handling</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Get the groupVersions exposed at /apis</span></span><br><span class="line">	apiGroupList = &amp;metav1.APIGroupList&#123;&#125;</span><br><span class="line">	err = d.restClient.Get().AbsPath(<span class="string">"/apis"</span>).Do().Into(apiGroupList)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; !errors.IsNotFound(err) &amp;&amp; !errors.IsForbidden(err) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// error handling</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// prepend the group retrieved from /api to the list if not empty</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(v.Versions) != <span class="number">0</span> &#123;</span><br><span class="line">		apiGroupList.Groups = <span class="built_in">append</span>([]metav1.APIGroup&#123;apiGroup&#125;, apiGroupList.Groups...)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> apiGroupList, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 RESTClient 请求 /api 接口，结果存放到 APIVersions 结构体，再次通过 RESTClient 请求 /apis 接口，请求结果存放到 APIGroupList 中。最后通过 /api 检索到的资源组信息合并到 apiGroupList 中返回。</p>
<p><strong>其实整个这些 API 的设计可以看出来，kubernetes 都是先声明一个对象，再将请求得到的数据通过 Into 方法装载进去，从而保证数据的“干净”性，这种设计理念贯穿了 RESTClient</strong>。</p>
<ol start="2">
<li>DiscoveryClient 的本地缓存</li>
</ol>
<p>缓存机制本身很简单，首次获取时，先查询本地缓存，不存在（没有命中）则请求 Kubernetes API Server 接口（回源）；Cache 把得到的响应数据存储本地一份并返回给 DiscoveryClient。下一次再次获取的时候，直接从本地缓存返回（命中）给 Client。默认10分钟与 APIServer 同步一次缓存，因为资源组，资源版本，资源信息几乎不变。</p>
<h2 id="Informer-机制"><a href="#Informer-机制" class="headerlink" title="Informer 机制"></a>Informer 机制</h2><p>Kubernets 中使用 http 进行通信，<strong>如何不依赖中间件的情况下保证消息的实时性，可靠性和顺序性等呢</strong>？答案就是利用了 Informer 机制。</p>
<h3 id="Informer-机制架构设计"><a href="#Informer-机制架构设计" class="headerlink" title="Informer 机制架构设计"></a>Informer 机制架构设计</h3><p><img src="001.jpg" alt=""></p>
<p>图片源自 <a href="https://github.com/kubernetes/sample-controller/blob/master/docs/controller-client-go.md" target="_blank" rel="noopener">Client-go under the hood</a></p>
<p>⚠️ 这张图分为两部分,黄色图标是开发者需要自行开发的部分，而其它的部分是client-go已经提供的，直接使用即可。</p>
<ol>
<li><strong>Reflector</strong>：用于 Watch 指定的 Kubernetes 资源，当 watch 的资源发生变化时，触发变更的事件，比如 Added，Updated 和 Deleted 事件，并将资源对象存放到本地缓存 DeltaFIFO；</li>
<li><strong>DeltaFIFO</strong>：拆开理解，FIFO 就是一个队列，拥有队列基本方法（ADD，UPDATE，DELETE，LIST，POP，CLOSE 等），Delta 是一个资源对象存储，保存存储对象的消费类型，比如 Added，Updated，Deleted，Sync 等；</li>
<li><strong>Indexer</strong>：Client-go 用来存储资源对象并自带索引功能的本地存储，Reflector 从 DeltaFIFO 中将消费出来的资源对象存储到 Indexer，Indexer 与 Etcd 集群中的数据完全保持一致（❓ <strong>需要关注这一步是如何达成的，以及性能上如何优化</strong>）。从而 client-go 可以本地读取，减少 Kubernetes API 和 Etcd 集群的压力。</li>
</ol>
<p>看书本 p146 的一个例子，关键流程如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">clientset, err := kubernetes.NewForConfig(config)</span><br><span class="line">stopCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(stopch)</span><br><span class="line">sharedInformers := informers.NewSharedInformerFactory(clientset, time.Minute)</span><br><span class="line">informer := sharedInformer.Core().V1().Pods().Informer()</span><br><span class="line">informer.AddEventHandler(cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">  AddFunc: <span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    // ...</span></span></span><br><span class="line"><span class="function"><span class="params">  &#125;,</span></span></span><br><span class="line"><span class="function"><span class="params">  UpdateFunc: <span class="keyword">func</span>(obj <span class="keyword">interface</span>&#123;&#125; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    // ...</span></span></span><br><span class="line"><span class="function"><span class="params">  &#125;,</span></span></span><br><span class="line"><span class="function"><span class="params">  DeleteFunc  : <span class="keyword">func</span>(obj <span class="keyword">interface</span>&#123;&#125; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    // ...</span></span></span><br><span class="line"><span class="function"><span class="params">  &#125;)</span></span></span><br><span class="line">  informer.Run(stopCh)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>Informer 需要通过高 ClientSet 与 Kubernetes API Server 交互；</li>
<li>创建 stopCh 是用于在程序进程退出前通知 Informer 提前退出，Informer 是一个持久运行的 goroutine；</li>
<li>NewSharedInformerFactory 实例化了一个 SharedInformer 对象，用于进行本地资源存储；</li>
<li>sharedInformer.Core().V1().Pods().Informer() 得到了具体 Pod 资源的 informer 对象；</li>
<li>AddEventHandler 即图中的第6步，这是一个资源事件回调方法，上例中即为当创建/更新/删除 Pod 时触发事件回调方法；</li>
<li>一般而言，其他组件使用 Informer 机制触发资源回调方法会将资源对象推送到 WorkQueue 或其他队列中，具体推送的位置要去回调方法里自行实现。</li>
</ul>
<p>上面这个示例，当触发了 Add，Update 或者 Delete 事件，就通知 Client-go，告知 Kubernetes 资源事件发生变更并且需要进行相应的处理。</p>
<ol>
<li>资源 Informer</li>
</ol>
<p>每一个 k8s Resource 都实现了 Informer 机制，均有 Informer 和 Lister 方法，以 PodInformer 为例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PodInformer <span class="keyword">interface</span> &#123;</span><br><span class="line">	Informer() cache.SharedIndexInformer</span><br><span class="line">	Lister() v1.PodLister</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>Shared Informer 共享机制</li>
</ol>
<p>Informer 又称为 Shared Informer，表明是可以共享使用的，在使用 client-go 写代码时，若同一资源的 Informer 被实例化太多次，每个 Informer 使用一个 Reflector，会运行过多的相同 ListAndWatch（即图中的第一步），太多重复的序列化和反序列化会导致 k8s API Server 负载过重。</p>
<p>而 Shared Informer 通过对同一类资源 Informer 共享一个 Reflector 可以节约很多资源，这通过 map 数据结构即可实现这样一个共享 Informer 机制。</p>
<p><code>vendor/k8s.io/client-go/informers/factory.go</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> sharedInformerFactory <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">	informers <span class="keyword">map</span>[reflect.Type]cache.SharedIndexInformer</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// InternalInformerFor returns the SharedIndexInformer for obj using an internal client.</span></span><br><span class="line"><span class="comment">// 当示例中调用 xxx.Informer() 时，内部调用了该方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *sharedInformerFactory)</span> <span class="title">InformerFor</span><span class="params">(obj runtime.Object, newFunc internalinterfaces.NewInformerFunc)</span> <span class="title">cache</span>.<span class="title">SharedIndexInformer</span></span> &#123;</span><br><span class="line">	f.lock.Lock()</span><br><span class="line">	<span class="keyword">defer</span> f.lock.Unlock()</span><br><span class="line"></span><br><span class="line">	informerType := reflect.TypeOf(obj)</span><br><span class="line">	informer, exists := f.informers[informerType]</span><br><span class="line">	<span class="keyword">if</span> exists &#123;</span><br><span class="line">		<span class="keyword">return</span> informer</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	resyncPeriod, exists := f.customResync[informerType]</span><br><span class="line">	<span class="keyword">if</span> !exists &#123;</span><br><span class="line">		resyncPeriod = f.defaultResync</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	informer = newFunc(f.client, resyncPeriod)</span><br><span class="line">	f.informers[informerType] = informer</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> informer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Reflector"><a href="#Reflector" class="headerlink" title="Reflector"></a>Reflector</h3><p>Reflector 用于 Watch 指定的 Kubernetes 资源，当 watch 的资源发生变化时，触发变更的事件，并将资源对象存放到本地缓存 DeltaFIFO。</p>
<p>通过 NewReflector 实例化 Reflector 对象，实例化过程必须传入 ListerWatcher 数据接口对象，它拥有 List 和 Watch 方法。Reflector 对象通过 Run 行数启动监控并处理监控事件，在实现中，其核心为 ListAndWatch 函数。</p>
<ol>
<li><strong>获取资源数据列表</strong></li>
</ol>
<p>以 Example 的代码为例，我们获取了所有 Pod 的资源数据，List 流程如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. r.ListWatcher.List 获取资源数据</span><br><span class="line">2. listMetaInterface.GetResourceVersion 获取资源版本号</span><br><span class="line">3. meta.ExtractList 将资源数据转换为资源对象列表</span><br><span class="line">4. r.SyncWith 将资源对象列表的资源对象和资源版本号存储到 DeltaFIFO 中</span><br><span class="line">5. r.setLastSyncResourceVersion 设置最新的资源版本号</span><br></pre></td></tr></table></figure>

<p>具体的，</p>
<ul>
<li>r.ListWatcher.List 根据 ResourceVersion 获取资源下的所有对象数据，List 具有类似于 “断点传输“ 的功能，当传输工程中遇到网络故障中断，下次连接时，会根据版本号继续传输未完成部分，是本地缓存与 etcd 集群中保持一致。以 Example 为例，该方法调用的就是 Pod Informer 下的 ListFunc 函数，通过 ClientSet 客户端与 Kubernetes API Server 交互并获取 Pod 资源列表数据；</li>
<li>listMetaInterface.GetResourceVersion 获取 ResourceVersion，即资源版本号，注意这里的资源版本号并不是指前面各个客户端的不同 kind 的不同 Version，所有资源都拥有 ResourceVersion，标识当前资源对象的版本号。每次修改 etcd 集群中存储的对象时，Kubernetes API Server 都会更改 ResourceVersion，使得 client-go 执行 watch 时可以根据 ResourceVersion 判断当前资源对象是否发生变化；</li>
<li>meta.ExtractList 将 runtime.Object 对象转换为 []runtime.Object 对象。因为 r.ListWatcher.List 获取的是资源下所有对象的数据，因此应当是一个列表；</li>
<li>r.SyncWith 将结果同步到 DeltaFIFO 中；</li>
<li>r.setLastSyncResourceVersion 设置最新的资源版本号</li>
</ul>
<ol start="2">
<li><strong>监控资源对象</strong></li>
</ol>
<p>Watch 通过 HTTP 协议与 Kubernets API Server 建立长连接，接收 Kubernets API Server 发来的资源变更事件。Watch 操作的实现机制使用 HTTP 协议的分块传输编码（Chunked Transfer Encoding）（❓ <strong>如何实现</strong>？）。——当 client-go 调用 Kubernets API Server 时，Kubernets API Server 在 Response 的 HTTP Header 中设置 Transfer-Encoding 的值为 chunked，表示采用分块传输编码，客户端收到消息后，与服务端进行连接，并等待下一个数据块。</p>
<p>在源码中关键为 watch 和 watchHandler 函数：</p>
<p><code>staging/src/k8s.io/client-go/tools/cache/reflector.go</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reflector)</span> <span class="title">ListAndWatch</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// list part</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// watch part</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// give the stopCh a chance to stop the loop, even in case of continue statements further down on errors</span></span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-stopCh:</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">		options = metav1.ListOptions&#123;</span><br><span class="line">			ResourceVersion: resourceVersion,</span><br><span class="line">			<span class="comment">// We want to avoid situations of hanging watchers. Stop any wachers that do not</span></span><br><span class="line">			<span class="comment">// receive any events within the timeout window.</span></span><br><span class="line">			TimeoutSeconds: &amp;timeoutSeconds,</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		w, err := r.listerWatcher.Watch(options)</span><br><span class="line">		<span class="comment">// error handling</span></span><br><span class="line">    </span><br><span class="line">		<span class="keyword">if</span> err := r.watchHandler(w, &amp;resourceVersion, resyncerrc, stopCh); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> err != errorStopRequested &#123;</span><br><span class="line">				klog.Warningf(<span class="string">"%s: watch of %v ended with: %v"</span>, r.name, r.expectedType, err)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以之前的 Example 为例子，r.listerWatcher.Watch 实际调用了 Pod Informer 下的 Watch 函数，通过 ClientSet 客户端与 Kubernetes API Server 建立长链接，监控指定资源的变更事件，如下：</p>
<p><code>staging/src/k8s.io/client-go/informers/core/v1/pod.go</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewFilteredPodInformer</span><span class="params">(...)</span> <span class="title">cache</span>.<span class="title">SharedIndexInformer</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> cache.NewSharedIndexInformer(</span><br><span class="line">		  <span class="comment">// ...</span></span><br><span class="line">			WatchFunc: <span class="function"><span class="keyword">func</span><span class="params">(options metav1.ListOptions)</span> <span class="params">(watch.Interface, error)</span></span> &#123;</span><br><span class="line">				<span class="keyword">if</span> tweakListOptions != <span class="literal">nil</span> &#123;</span><br><span class="line">					tweakListOptions(&amp;options)</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> client.CoreV1().Pods(namespace).Watch(options)</span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">	)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>r.watchHandler 处理资源的变更事件，将对应资源更新到本地缓存 DeltaFIFO 并更新 ResourceVersion 资源版本号。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// watchHandler watches w and keeps *resourceVersion up to date.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reflector)</span> <span class="title">watchHandler</span><span class="params">(w watch.Interface, resourceVersion *<span class="keyword">string</span>, errc <span class="keyword">chan</span> error, stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	start := r.clock.Now()</span><br><span class="line">	eventCount := <span class="number">0</span></span><br><span class="line">	<span class="keyword">defer</span> w.Stop()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环嵌套循环时，可以在break 后指定标签。用标签决定哪个循环被终止</span></span><br><span class="line">loop:</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-stopCh:</span><br><span class="line">			<span class="keyword">return</span> errorStopRequested</span><br><span class="line">		<span class="keyword">case</span> err := &lt;-errc:</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		<span class="keyword">case</span> event, ok := &lt;-w.ResultChan():</span><br><span class="line">      <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="comment">// 直接跳出 for 循环</span></span><br><span class="line">				<span class="keyword">break</span> loop</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// ...</span></span><br><span class="line">			newResourceVersion := meta.GetResourceVersion()</span><br><span class="line">			<span class="keyword">switch</span> event.Type &#123;</span><br><span class="line">			<span class="keyword">case</span> watch.Added:</span><br><span class="line">				err := r.store.Add(event.Object)</span><br><span class="line">				<span class="comment">// ...</span></span><br><span class="line">			<span class="keyword">case</span> watch.Modified:</span><br><span class="line">				err := r.store.Update(event.Object)</span><br><span class="line">				<span class="comment">// ...</span></span><br><span class="line">			<span class="keyword">case</span> watch.Deleted:</span><br><span class="line">				err := r.store.Delete(event.Object)</span><br><span class="line">				<span class="comment">// ...</span></span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="comment">// ...</span></span><br><span class="line">			&#125;</span><br><span class="line">			*resourceVersion = newResourceVersion</span><br><span class="line">			r.setLastSyncResourceVersion(newResourceVersion)</span><br><span class="line">			eventCount++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="DeltaFIFO"><a href="#DeltaFIFO" class="headerlink" title="DeltaFIFO"></a>DeltaFIFO</h3><p>DeltaFIFO 拆开理解，FIFO 就是一个队列，拥有队列基本方法（ADD，UPDATE，DELETE，LIST，POP，CLOSE 等），Delta 是一个资源对象存储，保存存储对象的消费类型，比如 Added，Updated，Deleted，Sync 等。</p>
<p>看 DeltaFIFO 的数据结构：</p>
<p><code>vendor/k8s.io/client-go/tools/cache/delta_fifo.go</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> DeltaFIFO <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// lock/cond protects access to 'items' and 'queue'.</span></span><br><span class="line">	lock sync.RWMutex</span><br><span class="line">	cond sync.Cond</span><br><span class="line"></span><br><span class="line">	<span class="comment">// We depend on the property that items in the set are in</span></span><br><span class="line">	<span class="comment">// the queue and vice versa, and that all Deltas in this</span></span><br><span class="line">	<span class="comment">// map have at least one Delta.</span></span><br><span class="line">	items <span class="keyword">map</span>[<span class="keyword">string</span>]Deltas</span><br><span class="line">	queue []<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，Deltas 部分的数据结构如下：</p>
<p><code>staging/src/k8s.io/client-go/tools/cache/delta_fifo.go</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DeltaType is the type of a change (addition, deletion, etc)</span></span><br><span class="line"><span class="keyword">type</span> DeltaType <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Delta is the type stored by a DeltaFIFO. It tells you what change</span></span><br><span class="line"><span class="comment">// happened, and the object's state after* that change.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// [*] Unless the change is a deletion, and then you'll get the final</span></span><br><span class="line"><span class="comment">//     state of the object before it was deleted.</span></span><br><span class="line"><span class="keyword">type</span> Delta <span class="keyword">struct</span> &#123;</span><br><span class="line">	Type   DeltaType</span><br><span class="line">	Object <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Deltas is a list of one or more 'Delta's to an individual object.</span></span><br><span class="line"><span class="comment">// The oldest delta is at index 0, the newest delta is the last one.</span></span><br><span class="line"><span class="keyword">type</span> Deltas []Delta</span><br></pre></td></tr></table></figure>

<p>DeltaFIFO 与其他队列最大的不同之处在于：它会保留所有关于资源对象（obj）的操作类型，队列中会存在拥有不同操作类型的同一资源对象，<strong>使得消费者在处理该资源对象时能够了解资源对象所发生的事情</strong>。queue 字段存储资源对象的 key，这个 key 通过 KeyOf 函数计算得到，items 字段通过 map 数据结构的方式存储，value 存储的是对象 Deltas 数组，结构图如下：</p>
<p><img src="004.png" alt=""></p>
<p>作为一个 FIFO 的队列，有数据的生产者和消费者，其中生产者是 Reflector 调用的 Add 方法，消费者是 Controller 调用的 Pop 方法。三个核心方法为生产者方法，消费者方法和 Resync 机制。</p>
<h4 id="生产者方法"><a href="#生产者方法" class="headerlink" title="生产者方法"></a>生产者方法</h4><p>DeltaFIFO 队列中的资源对象在调用 Added，Updated，Deleted 等事件时都调用了 queueActionLocked 函数：</p>
<p><img src="002.png" alt=""></p>
<p>它是 DeltaFIFO 实现的关键：</p>
<p><code>vendor/k8s.io/client-go/tools/cache/delta_fifo.go</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// queueActionLocked appends to the delta list for the object.</span></span><br><span class="line"><span class="comment">// Caller must lock first.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *DeltaFIFO)</span> <span class="title">queueActionLocked</span><span class="params">(actionType DeltaType, obj <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	id, err := f.KeyOf(obj)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> KeyError&#123;obj, err&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	newDeltas := <span class="built_in">append</span>(f.items[id], Delta&#123;actionType, obj&#125;)</span><br><span class="line">	newDeltas = dedupDeltas(newDeltas)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(newDeltas) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> _, exists := f.items[id]; !exists &#123;</span><br><span class="line">			f.queue = <span class="built_in">append</span>(f.queue, id)</span><br><span class="line">		&#125;</span><br><span class="line">		f.items[id] = newDeltas</span><br><span class="line">		f.cond.Broadcast()</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// We need to remove this from our map (extra items in the queue are</span></span><br><span class="line">		<span class="comment">// ignored if they are not in the map).</span></span><br><span class="line">		<span class="built_in">delete</span>(f.items, id)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>通过 KeyOf 函数计算出对象的 key；</li>
<li>将 actionType 以及对应的 id 添加到 items 中，并通过 dedupDeltas 对数组中最新的两次添加进行去重；</li>
<li>更新构造后的 Deleta 并通过 cond.Broadcast() 广播所有消费者解除阻塞。</li>
</ol>
<h4 id="消费者方法"><a href="#消费者方法" class="headerlink" title="消费者方法"></a>消费者方法</h4><p>Pop 函数作为消费者使用方法，从 DeltaFIFO 的头部取出最早进入队列中的资源对象数据。Pop 方法必须传入 process 函数，用于接收并处理对象的回调方法，如下：</p>
<p><code>vendor/k8s.io/client-go/tools/cache/delta_fifo.go</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *DeltaFIFO)</span> <span class="title">Pop</span><span class="params">(process PopProcessFunc)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">	f.lock.Lock()</span><br><span class="line">	<span class="keyword">defer</span> f.lock.Unlock()</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> <span class="built_in">len</span>(f.queue) == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="comment">// When the queue is empty, invocation of Pop() is blocked until new item is enqueued.</span></span><br><span class="line">			<span class="comment">// When Close() is called, the f.closed is set and the condition is broadcasted.</span></span><br><span class="line">			<span class="comment">// Which causes this loop to continue and return from the Pop().</span></span><br><span class="line">			<span class="keyword">if</span> f.IsClosed() &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, FIFOClosedError</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			f.cond.Wait()</span><br><span class="line">		&#125;</span><br><span class="line">		id := f.queue[<span class="number">0</span>]</span><br><span class="line">		f.queue = f.queue[<span class="number">1</span>:]</span><br><span class="line">		<span class="keyword">if</span> f.initialPopulationCount &gt; <span class="number">0</span> &#123;</span><br><span class="line">			f.initialPopulationCount--</span><br><span class="line">		&#125;</span><br><span class="line">		item, ok := f.items[id]</span><br><span class="line">		<span class="keyword">if</span> !ok &#123;</span><br><span class="line">			<span class="comment">// Item may have been deleted subsequently.</span></span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">    <span class="comment">// ⚠️ 这里在执行之前会把该 obj 旧的 delta 数据清空</span></span><br><span class="line">		<span class="built_in">delete</span>(f.items, id)</span><br><span class="line">		err := process(item)</span><br><span class="line">		<span class="keyword">if</span> e, ok := err.(ErrRequeue); ok &#123;</span><br><span class="line">			f.addIfNotPresent(id, item)</span><br><span class="line">			err = e.Err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Don't need to copyDeltas here, because we're transferring</span></span><br><span class="line">		<span class="comment">// ownership to the caller.</span></span><br><span class="line">		<span class="keyword">return</span> item, err</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，使用 f.lock.Lock() 确保了数据的同步，当队列不为空时，取出 f.queue 的头部数据，将对象传入 process 回调函数，由上层消费者进行处理，如果 process 回调方法处理出错，将该对象重新存入队列。</p>
<p>Controller 的 processLoop 方法负责从 DeltaFIFO 队列中取出数据传递给 process 回调函数，process 函数的类型如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PopProcessFunc <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>

<p>一个 process 回调函数代码示例如下：</p>
<p><code>vendor/k8s.io/client-go/tools/cache/shared_informer.go</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *sharedIndexInformer)</span> <span class="title">HandleDeltas</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	s.blockDeltas.Lock()</span><br><span class="line">	<span class="keyword">defer</span> s.blockDeltas.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// from oldest to newest</span></span><br><span class="line">	<span class="keyword">for</span> _, d := <span class="keyword">range</span> obj.(Deltas) &#123;</span><br><span class="line">		<span class="keyword">switch</span> d.Type &#123;</span><br><span class="line">		<span class="keyword">case</span> Sync, Added, Updated:</span><br><span class="line">			isSync := d.Type == Sync</span><br><span class="line">			s.cacheMutationDetector.AddObject(d.Object)</span><br><span class="line">			<span class="keyword">if</span> old, exists, err := s.indexer.Get(d.Object); err == <span class="literal">nil</span> &amp;&amp; exists &#123;</span><br><span class="line">				<span class="keyword">if</span> err := s.indexer.Update(d.Object); err != <span class="literal">nil</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> err</span><br><span class="line">				&#125;</span><br><span class="line">				s.processor.distribute(updateNotification&#123;oldObj: old, newObj: d.Object&#125;, isSync)</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> err := s.indexer.Add(d.Object); err != <span class="literal">nil</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> err</span><br><span class="line">				&#125;</span><br><span class="line">				s.processor.distribute(addNotification&#123;newObj: d.Object&#125;, isSync)</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">case</span> Deleted:</span><br><span class="line">			<span class="keyword">if</span> err := s.indexer.Delete(d.Object); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">			&#125;</span><br><span class="line">			s.processor.distribute(deleteNotification&#123;oldObj: d.Object&#125;, <span class="literal">false</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，HandleDeltas 作为 process 的一个回调函数，当资源对象操作类型为 Added，Updated 和 Delted 时，该资源对象存储至 Indexer（它是并发安全的），并通过 distribute 函数将资源对象分发到 SharedInformer，在之前 <a href="#informer-机制架构设计">Informer 机制架构设计</a>的示例代码中，通过 <code>informer.AddEventHandler</code> 函数添加了对资源事件进行处理的函数，distribute 函数将资源对象分发到该事件处理函数。</p>
<blockquote>
<p> 一个当时学到这里遇到的问题：<a href="https://github.com/cloudnativeto/sig-k8s-source-code/issues/29" target="_blank" rel="noopener">【提问】DeltaFIFO 消费者方法中 process 回调函数的实现</a></p>
</blockquote>
<h4 id="Resync-机制"><a href="#Resync-机制" class="headerlink" title="Resync 机制"></a>Resync 机制</h4><blockquote>
<p>本节内容基本搬运自 <a href="https://github.com/cloudnativeto/sig-k8s-source-code/issues/11" target="_blank" rel="noopener">【提问】Informer 中为什么需要引入 Resync 机制？</a></p>
</blockquote>
<p>Resync 机制会将 Indexer 本地存储中的资源对象同步到 DeltaFIFO 中，并将这些资源对象设置为 Sync 的操作类型，</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// k8s.io/client-go/tools/cache/delta_fifo.go</span></span><br><span class="line"><span class="comment">// 重新同步一次 Indexer 缓存数据到 Delta FIFO 队列中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *DeltaFIFO)</span> <span class="title">Resync</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	f.lock.Lock()</span><br><span class="line">	<span class="keyword">defer</span> f.lock.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> f.knownObjects == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 遍历 indexer 中的 key，传入 syncKeyLocked 中处理</span></span><br><span class="line">	keys := f.knownObjects.ListKeys()</span><br><span class="line">	<span class="keyword">for</span> _, k := <span class="keyword">range</span> keys &#123;</span><br><span class="line">		<span class="keyword">if</span> err := f.syncKeyLocked(k); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *DeltaFIFO)</span> <span class="title">syncKeyLocked</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	obj, exists, err := f.knownObjects.GetByKey(key)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		klog.Errorf(<span class="string">"Unexpected error %v during lookup of key %v, unable to queue object for sync"</span>, err, key)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> !exists &#123;</span><br><span class="line">		klog.Infof(<span class="string">"Key %v does not exist in known objects store, unable to queue object for sync"</span>, key)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果发现 FIFO 队列中已经有相同 key 的 event 进来了，说明该资源对象有了新的 event，</span></span><br><span class="line">	<span class="comment">// 在 Indexer 中旧的缓存应该失效，因此不做 Resync 处理直接返回 nil</span></span><br><span class="line">	id, err := f.KeyOf(obj)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> KeyError&#123;obj, err&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(f.items[id]) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 重新放入 FIFO 队列中</span></span><br><span class="line">	<span class="keyword">if</span> err := f.queueActionLocked(Sync, obj); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">"couldn't queue object: %v"</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么需要 Resync 机制呢？因为在处理 SharedInformer 事件回调时，可能存在处理失败的情况，定时的 Resync 让这些处理失败的事件有了重新 onUpdate 处理的机会。</p>
<p>那么经过 Resync 重新放入 Delta FIFO 队列的事件，和直接从 apiserver 中 watch 得到的事件处理起来有什么不一样呢？还是看 HandleDeltas：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// k8s.io/client-go/tools/cache/shared_informer.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *sharedIndexInformer)</span> <span class="title">HandleDeltas</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	s.blockDeltas.Lock()</span><br><span class="line">	<span class="keyword">defer</span> s.blockDeltas.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// from oldest to newest</span></span><br><span class="line">	<span class="keyword">for</span> _, d := <span class="keyword">range</span> obj.(Deltas) &#123;</span><br><span class="line">		<span class="comment">// 判断事件类型，看事件是通过新增、更新、替换、删除还是 Resync 重新同步产生的</span></span><br><span class="line">		<span class="keyword">switch</span> d.Type &#123;</span><br><span class="line">		<span class="keyword">case</span> Sync, Replaced, Added, Updated:</span><br><span class="line">			s.cacheMutationDetector.AddObject(d.Object)</span><br><span class="line">			<span class="keyword">if</span> old, exists, err := s.indexer.Get(d.Object); err == <span class="literal">nil</span> &amp;&amp; exists &#123;</span><br><span class="line">				<span class="keyword">if</span> err := s.indexer.Update(d.Object); err != <span class="literal">nil</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> err</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">				isSync := <span class="literal">false</span></span><br><span class="line">				<span class="keyword">switch</span> &#123;</span><br><span class="line">				<span class="keyword">case</span> d.Type == Sync:</span><br><span class="line">					<span class="comment">// 如果是通过 Resync 重新同步得到的事件则做个标记</span></span><br><span class="line">					isSync = <span class="literal">true</span></span><br><span class="line">				<span class="keyword">case</span> d.Type == Replaced:</span><br><span class="line">					...</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 如果是通过 Resync 重新同步得到的事件，则触发 onUpdate 回调</span></span><br><span class="line">				s.processor.distribute(updateNotification&#123;oldObj: old, newObj: d.Object&#125;, isSync)</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> err := s.indexer.Add(d.Object); err != <span class="literal">nil</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> err</span><br><span class="line">				&#125;</span><br><span class="line">				s.processor.distribute(addNotification&#123;newObj: d.Object&#125;, <span class="literal">false</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">case</span> Deleted:</span><br><span class="line">			<span class="keyword">if</span> err := s.indexer.Delete(d.Object); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">			&#125;</span><br><span class="line">			s.processor.distribute(deleteNotification&#123;oldObj: d.Object&#125;, <span class="literal">false</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面对 Delta FIFO 的队列处理源码可看出，如果是从 Resync 重新同步到 Delta FIFO 队列的事件，会分发到 updateNotification 中触发 onUpdate 的回调。Resync 机制的引入，定时将 Indexer 缓存事件重新同步到 Delta FIFO 队列中，在处理 SharedInformer 事件回调时，让处理失败的事件得到重新处理。并且通过入队前判断 FIFO 队列中是否已经有了更新版本的 event，来决定是否丢弃 Indexer 缓存不进行 Resync 入队。在处理 Delta FIFO 队列中的 Resync 的事件数据时，触发 onUpdate 回调来让事件重新处理。</p>
<p>关于为什么使用 Resync，这个问题在《Programming Kubernetes》的第一章详细解释了一遍，我搬运一下。主要的目的是为了不丢数据，处理 <code>resync</code> 机制还有边缘触发与水平获取的设计，一起来保证不丢事件、数据同步并能及时响应事件。</p>
<blockquote>
<p>在分布式系统中，有许多操作在并行执行，事件可能会以任意顺序异步到达。 如果我们的 controller 逻辑有问题，状态机出现一些错误或外部服务故障时，就很容易丢失事件，导致我们没有处理所有事件。 因此，我们必须更深入地研究如何应对这些问题。</p>
<p>在图中，您可以看到可用的不同方案：</p>
<ol>
<li>仅使用边缘驱动逻辑的示例，其中可能错过第二个的状态更改事件。</li>
<li>边缘触发逻辑的示例，在处理事件时始终会获取最新状态（即水平）。换句话说，逻辑是边缘触发的（edge-triggered），但是水平驱动的（level-driven）。</li>
<li>该示例的逻辑是边缘触发，水平驱动的，但同时还附加了定时同步的能力。</li>
</ol>
<p><img src="003.png" alt=""></p>
<p>考虑到仅使用单一的边缘驱动触发会产生的问题，Kubernetes controller 通常采用第 3 种方案。</p>
</blockquote>
<h3 id="Indexer"><a href="#Indexer" class="headerlink" title="Indexer"></a>Indexer</h3><p>Client-go 用来存储资源对象并自带索引功能的本地存储，Reflector 从 DeltaFIFO 中将消费出来的资源对象存储到 Indexer，Indexer 与 Etcd 集群中的数据完全保持一致。从而 client-go 可以本地读取，减少 Kubernetes API 和 Etcd 集群的压力。</p>
<p>了解 Indexer 之前，先了解 ThreadSafeMap，ThreadSafeMap 是实现并发安全存储，就像 Go 1.9 后推出 <code>sync.Map</code> 一样。Kubernetes 开始编写的时候还没有 <code>sync.Map</code>。Indexer 在 ThreadSafeMap 的基础上进行了封装，继承了 ThreadSafeMap 的存储相关的增删改查相关操作方法，实现了 Indexer Func 等功能，例如 Index，IndexKeys，GetIndexers 等方法，这些方法为 ThreadSafeMap 提供了索引功能。如下图：</p>
<p><img src="005.png" alt=""></p>
<h4 id="ThreadSafeStore"><a href="#ThreadSafeStore" class="headerlink" title="ThreadSafeStore"></a>ThreadSafeStore</h4><p>ThreadSafeStore 是一个内存中存储，数据不会写入本地磁盘，增删改查都会加锁，保证数据一致性。结构如下：</p>
<p><code>vendor/k8s.io/client-go/tools/cache/store.go</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// threadSafeMap implements ThreadSafeStore</span></span><br><span class="line"><span class="keyword">type</span> threadSafeMap <span class="keyword">struct</span> &#123;</span><br><span class="line">	lock  sync.RWMutex</span><br><span class="line">	items <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// indexers maps a name to an IndexFunc</span></span><br><span class="line">	indexers Indexers</span><br><span class="line">	<span class="comment">// indices maps a name to an Index</span></span><br><span class="line">	indices Indices</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>items 字段存储资源对象数据，其中 items 的 key 通过 keyFunc 函数计算得到，计算默认使用 MetaNamespaceKeyFunc 函数，该函数根据资源对象计算出 <code>&lt;namespace&gt;/&lt;name&gt;</code> 格式的 key，value 用于存储资源对象。</p>
<p>而后面两个字段的定义类型如下：</p>
<p><code>vendor/k8s.io/client-go/tools/cache/index.go</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Index maps the indexed value to a set of keys in the store that match on that value</span></span><br><span class="line"><span class="keyword">type</span> Index <span class="keyword">map</span>[<span class="keyword">string</span>]sets.String</span><br><span class="line"></span><br><span class="line"><span class="comment">// Indexers maps a name to a IndexFunc</span></span><br><span class="line"><span class="keyword">type</span> Indexers <span class="keyword">map</span>[<span class="keyword">string</span>]IndexFunc</span><br><span class="line"></span><br><span class="line"><span class="comment">// Indices maps a name to an Index</span></span><br><span class="line"><span class="keyword">type</span> Indices <span class="keyword">map</span>[<span class="keyword">string</span>]Index</span><br></pre></td></tr></table></figure>

<h4 id="Indexer-索引器"><a href="#Indexer-索引器" class="headerlink" title="Indexer 索引器"></a>Indexer 索引器</h4><p>每次增删改 ThreadSafeStore 的数据时，都会通过 updateIndices 或 deleteFormIndices 函数变更 Indexer。Indexer 被设计为可以自定义索引函数，他有重要的四个数据结构，<strong>Indexers</strong>，<strong>IndexFunc</strong>，<strong>Indices</strong> 和 <strong>Index</strong>。</p>
<p>看书本 159 页这个例子。</p>
<p>首先定义了一个索引器函数（IndexFunc），UsersIndexFunc。该函数定义查询所有 Pod 资源下 Annotations 字段的 key 为 users 的 Pod：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UsersIndexFunc</span><span class="params">(obj interfaces&#123;&#125;)</span> <span class="params">([]<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">  pod := obj.(*v1.Pod)</span><br><span class="line">  usersString := pod.Annotations[<span class="string">"users"</span>]</span><br><span class="line">  <span class="keyword">return</span> strings.Split(userString, <span class="string">","</span>), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Main 函数中 <code>cache.NewIndexer</code> 实例化了一个 Indexer 对象：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index := cache.NewIndexer(cache.MetaNamespaceKeyFunc, cache.Indexers&#123;<span class="string">"byUser"</span>: UsersIndexFunc&#125;)</span><br></pre></td></tr></table></figure>

<p>第一个参数计算资源对象的 key，默认就是 MetaNamespaceKeyFunc，第二个参数是一个 Indexers 对象，如上一节展示的定义那样，key 为索引器（IndexFunc）的名称，value 为索引器函数。</p>
<p>通过 index.Add 添加了三个 Pod，再通过 index.ByIndex 函数查询使用 byUser 索引器下匹配 ernie 字段的 Pod 列表：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">erniePods, err := index.ByIndex(<span class="string">"byUser"</span>, <span class="string">"ernie"</span>)</span><br></pre></td></tr></table></figure>

<p>回看这四个类型：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Indexers maps a name to a IndexFunc</span></span><br><span class="line"><span class="keyword">type</span> Indexers <span class="keyword">map</span>[<span class="keyword">string</span>]IndexFunc</span><br><span class="line"></span><br><span class="line"><span class="comment">// IndexFunc knows how to provide an indexed value for an object.</span></span><br><span class="line"><span class="keyword">type</span> IndexFunc <span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">([]<span class="keyword">string</span>, error)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Indices maps a name to an Index</span></span><br><span class="line"><span class="keyword">type</span> Indices <span class="keyword">map</span>[<span class="keyword">string</span>]Index</span><br><span class="line"></span><br><span class="line"><span class="comment">// Index maps the indexed value to a set of keys in the store that match on that value</span></span><br><span class="line"><span class="keyword">type</span> Index <span class="keyword">map</span>[<span class="keyword">string</span>]sets.String</span><br></pre></td></tr></table></figure>

<ul>
<li>Indexers：存储索引器，key 为 索引器名称，value 为索引器实现函数；</li>
<li>IndexFunc：索引器函数，定义为接收一个资源对象，返回检索结果列表；</li>
<li>Indices：存储缓存器，key 为缓存器名称，value 为缓存数据；（❓书中表示这个缓存器命名和索引器命名相对应未看懂）</li>
<li>Index：存储缓存数据，结构为 K/V。</li>
</ul>
<h4 id="Indexer-索引器核心实现"><a href="#Indexer-索引器核心实现" class="headerlink" title="Indexer 索引器核心实现"></a>Indexer 索引器核心实现</h4><p><code>vendor/k8s.io/client-go/tools/cache/thread_safe_store.go</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ByIndex returns a list of items that match an exact value on the index function</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *threadSafeMap)</span> <span class="title">ByIndex</span><span class="params">(indexName, indexKey <span class="keyword">string</span>)</span> <span class="params">([]<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">	c.lock.RLock()</span><br><span class="line">	<span class="keyword">defer</span> c.lock.RUnlock()</span><br><span class="line"></span><br><span class="line">	indexFunc := c.indexers[indexName]</span><br><span class="line">	<span class="keyword">if</span> indexFunc == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"Index with name %s does not exist"</span>, indexName)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	index := c.indices[indexName]</span><br><span class="line"></span><br><span class="line">	set := index[indexKey]</span><br><span class="line">	list := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="number">0</span>, set.Len())</span><br><span class="line">	<span class="keyword">for</span> _, key := <span class="keyword">range</span> set.List() &#123;</span><br><span class="line">		list = <span class="built_in">append</span>(list, c.items[key])</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> list, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ByIndex 接收两个参数：indexName（索引器名字）以及 indexKey（需要检索的 key），首先从 c.indexers 查找制定的索引器函数，然后从 c.indices 查找返回的缓存器函数，最后根据需要索引的 indexKey 从缓存数据中查到并返回。</p>
<p>⚠️ K8s 将 map 结构类型的 key 作为 Set 数据结构，实现 Set 去重特性。</p>
<h2 id="WorkQueue"><a href="#WorkQueue" class="headerlink" title="WorkQueue"></a>WorkQueue</h2><p>还是这张图，下半部分就是我们这节要学习的 WorkQueue。</p>
<p><img src="001.png" alt=""></p>
<p>WorkQueue 的实现比 FIFO 略为复杂，它主要功能在于标记和去重。</p>
<ul>
<li><strong>有序</strong>：按照添加顺序处理元素（item）；</li>
<li><strong>去重</strong>：相同元素在同一时间不会被重复处理，例如一个元素在处理之前被添加了多次，它只会被处理一次；</li>
<li><strong>并发性</strong>：多生产者和多消费者；</li>
<li><strong>标记机制</strong>：支持标记功能，标记一个元素是否被处理，也允许在处理时重新排队；</li>
<li><strong>通知机制</strong>：ShutDown 方法通过信号量通知队列不再接收新元素，并通知 metric goroutine 退出；</li>
<li><strong>延迟</strong>：支持延迟队列，延迟一段时间后再将元素存入队列；</li>
<li><strong>限速</strong>：支持限速队列，元素存入队列时进行速率限制，限制一个元素被重新排队的次数；</li>
<li><strong>Metric</strong>：支持 metric 指标，用于 prometheus 监控。</li>
</ul>
<p>WorkQueue 实现三种队列，提供三种接口，不同队列实现可应对不同的使用场景，分别介绍如下：</p>
<blockquote>
<p>不理解这种命名原因，感觉很鬼……</p>
</blockquote>
<ul>
<li><strong>Interface</strong>：FIFO 队列接口，先进先出队列，支持去重机制；</li>
<li><strong>DelayingInterface</strong>：延迟队列接口，基于 Interface 接口封装，延迟一段时间后再将元素存入队列；</li>
<li><strong>RateLimitingInterface</strong>：限速队列接口，基于 DelayingInterface 接口封装，支持元素存入队列时进行速率限制。</li>
</ul>
<h3 id="FIFO-队列"><a href="#FIFO-队列" class="headerlink" title="FIFO 队列"></a>FIFO 队列</h3><p>FIFO 提供方法如下：</p>
<p><code>vendor/k8s.io/client-go/util/workqueue/queue.go</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">	Add(item <span class="keyword">interface</span>&#123;&#125;)	<span class="comment">// 添加元素（item）</span></span><br><span class="line">	Len() <span class="keyword">int</span> <span class="comment">// 返回队列长度</span></span><br><span class="line">	Get() (item <span class="keyword">interface</span>&#123;&#125;, shutdown <span class="keyword">bool</span>) <span class="comment">// 获取队列头部的一个元素</span></span><br><span class="line">	Done(item <span class="keyword">interface</span>&#123;&#125;) <span class="comment">// 标记队列中 item 已经被处理</span></span><br><span class="line">	ShutDown() <span class="comment">// 关闭队列</span></span><br><span class="line">	ShuttingDown() <span class="keyword">bool</span> <span class="comment">// 查询队列是否正在关闭</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FIFO 队列数据结构如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Type <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// queue defines the order in which we will work on items. Every</span></span><br><span class="line">	<span class="comment">// element of queue should be in the dirty set and not in the</span></span><br><span class="line">	<span class="comment">// processing set.</span></span><br><span class="line">	queue []t</span><br><span class="line"></span><br><span class="line">	<span class="comment">// dirty defines all of the items that need to be processed.</span></span><br><span class="line">	dirty set</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Things that are currently being processed are in the processing set.</span></span><br><span class="line">	<span class="comment">// These things may be simultaneously in the dirty set. When we finish</span></span><br><span class="line">	<span class="comment">// processing something and remove it from this set, we'll check if</span></span><br><span class="line">	<span class="comment">// it's in the dirty set, and if so, add it to the queue.</span></span><br><span class="line">	processing set</span><br><span class="line"></span><br><span class="line">	cond *sync.Cond</span><br><span class="line"></span><br><span class="line">	shuttingDown <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">	metrics queueMetrics</span><br><span class="line"></span><br><span class="line">	unfinishedWorkUpdatePeriod time.Duration</span><br><span class="line">	clock                      clock.Clock</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最主要是三个字段：queue，dirty 和 processing。queue 是实际存储元素的地方，是 slice 结构，保证元素有序；dirty 字段非常关键，结构为 set，保证去重，还能保证在处理一个元素之前哪怕被添加了多次（并发情况下）也只会处理一次；processing 字段用于标记元素是否正在被处理。存储过程如下所示：</p>
<ol>
<li>通过 ADD 方法往 FIFO 插入 1，2，3 这三个元素，此时<strong>队列</strong>中的 queue 和 <strong>set</strong> 类型的 dirty 均有 1，2，3，processing 为空；</li>
<li>通过 Get 获取最先进入的元素，队列 queue 和集合 dirty 更新为 2，3，1 被放入 processing 表示正在处理；</li>
<li>处理完1元素，通过 DONE 表示元素处理完成，processing 1 被删除。</li>
</ol>
<p>如果是刚并发下如何保证上述流程？</p>
<p>并发场景下，goroutine A 通过 Get 获取1，1 入 processing；同时 goroutine B 通过 ADD 添加1，此时 proccessing 已经处理相同元素，所以 1 不会添加到 queue 中，等 processing 中的 1 done 以后，1 被添加到 queue 中。</p>
<p>看一下对应的代码：</p>
<p><code>vendor/k8s.io/client-go/util/workqueue/queue.go</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Type)</span> <span class="title">Add</span><span class="params">(item <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 和pthread_cond_t不同的是golang的cond自带了互斥锁</span></span><br><span class="line">    q.cond.L.Lock()</span><br><span class="line">    <span class="keyword">defer</span> q.cond.L.Unlock()</span><br><span class="line">    <span class="comment">// 队列正在关闭，则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> q.shuttingDown &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 已经标记为dirt的数据，也直接返回，因为存储在了脏数据的集合中</span></span><br><span class="line">    <span class="keyword">if</span> q.dirty.has(item) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 告知metrics添加元素</span></span><br><span class="line">    q.metrics.add(item)</span><br><span class="line">    <span class="comment">// 添加到脏数据集合中</span></span><br><span class="line">    q.dirty.insert(item)</span><br><span class="line">    <span class="comment">// 元素如果正在被处理，那就直接返回</span></span><br><span class="line">    <span class="keyword">if</span> q.processing.has(item) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 追加到元素数组的尾部</span></span><br><span class="line">    q.queue = <span class="built_in">append</span>(q.queue, item)</span><br><span class="line">    <span class="comment">// 通知有新元素到了，此时有协程阻塞就会被唤醒</span></span><br><span class="line">    q.cond.Signal()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>队列添加元素有几种状态：</p>
<ol>
<li>队列关闭了，所以不接受任何数据；</li>
<li>队列中没有该元素，那就直接存储在队列中；</li>
<li>队列中已经有了该元素，这个改如何判断呢？set 类型肯定是最快的（用 map 实现，时间复杂度为 O(1)），数组需要遍历效率太低，这也是 dirty 存在的价值之一，上面的代码也通过 dirty 判断元素是否存在的；</li>
<li>队列中曾经存储过该元素，但是已经被拿走还没有调用 <code>Done()</code> 方法时，也就是正在处理中的元素，此时再添加当前的元素应该是最新的，处理中的应该是过时的，也就是脏的。</li>
</ol>
<p>综合上面几种状态就比较好理解 dirty 的存在了，正常情况下元素只会在 processing 和 dirty 存一份，同时存在就说明该元素在被处理的同时又被添加了一次，那么先前的那次可以理解为脏的，后续添加的要再被处理。</p>
<p>再来看看 <code>Get()</code> 函数是如何实现的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get() 会阻塞直到它可以返回要处理的元素。如果 shutdown=true，则调用方应该结束其 goroutine，处理完元素后，必须调用 Done() 方法。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Type)</span> <span class="title">Get</span><span class="params">()</span> <span class="params">(item <span class="keyword">interface</span>&#123;&#125;, shutdown <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    q.cond.L.Lock()</span><br><span class="line">    <span class="keyword">defer</span> q.cond.L.Unlock()</span><br><span class="line">    <span class="comment">// 如果当前队列中没有数据，并且没有要关闭的状态则阻塞协程</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(q.queue) == <span class="number">0</span> &amp;&amp; !q.shuttingDown &#123;</span><br><span class="line">        q.cond.Wait()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 协程被激活但还没有数据，说明队列被关闭了</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(q.queue) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 必须返回关闭中的状态</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从队列中弹出第一个元素</span></span><br><span class="line">    item, q.queue = q.queue[<span class="number">0</span>], q.queue[<span class="number">1</span>:]</span><br><span class="line">    <span class="comment">// 通知metrics获取元素</span></span><br><span class="line">    q.metrics.get(item)</span><br><span class="line">    <span class="comment">// 加入到处理队列中</span></span><br><span class="line">    q.processing.insert(item)</span><br><span class="line">    <span class="comment">// 同时从dirty集合（需要处理的元素集合）中移除</span></span><br><span class="line">    q.dirty.<span class="built_in">delete</span>(item)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> item, <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后 <code>Done()</code> 函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Done 标记元素为处理中，当被处理时如果已经又被标记为 dirty，则会将其重新添加到队列中进行重新处理。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Type)</span> <span class="title">Done</span><span class="params">(item <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    q.cond.L.Lock()</span><br><span class="line">    <span class="keyword">defer</span> q.cond.L.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通知 metrics 元素处理完了</span></span><br><span class="line">    q.metrics.done(item)</span><br><span class="line">    <span class="comment">// 从正在处理的集合中删除元素</span></span><br><span class="line">    q.processing.<span class="built_in">delete</span>(item)</span><br><span class="line">    <span class="comment">// 此处判断脏数据集合，如果在处理期间又被添加回去了，则又放到队列中重新处理。</span></span><br><span class="line">    <span class="keyword">if</span> q.dirty.has(item) &#123;</span><br><span class="line">        q.queue = <span class="built_in">append</span>(q.queue, item)</span><br><span class="line">        q.cond.Signal()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列</h3><p>延迟队列基于 FIFO 封装，在原有功能增加 AddAfter 方法，其原理是延迟一段时间后再将元素插入 FIFO 队列。在日常使用中，我们一般将 DelayQueue 作用于以下场景 ：</p>
<ul>
<li>缓存系统 ： 当能够从 DelayQueue 中获取元素时，说该缓存已过期；</li>
<li>定时任务调度。</li>
</ul>
<p>在 client-go 中，延迟队列使得在失败后重新排列元素更容易而不会在热循环中结束。</p>
<p><code>vendor/k8s.io/client-go/util/workqueue/delaying_queue.go</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DelayingInterface is an Interface that can Add an item at a later time. This makes it easier to</span></span><br><span class="line"><span class="comment">// requeue items after failures without ending up in a hot-loop.</span></span><br><span class="line"><span class="keyword">type</span> DelayingInterface <span class="keyword">interface</span> &#123;</span><br><span class="line">	Interface</span><br><span class="line">	<span class="comment">// AddAfter adds an item to the workqueue after the indicated duration has passed</span></span><br><span class="line">	AddAfter(item <span class="keyword">interface</span>&#123;&#125;, duration time.Duration)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// client-go/util/workqueue/delaying_queue.go</span></span><br><span class="line"><span class="comment">// delayingType 包装了 Interface 然后提供了延迟 re-enquing</span></span><br><span class="line"><span class="keyword">type</span> delayingType <span class="keyword">struct</span> &#123;</span><br><span class="line">    Interface  <span class="comment">// 通用队列的实现</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 时钟，用于获取时间</span></span><br><span class="line">    clock clock.Clock</span><br><span class="line">    <span class="comment">// 延时就需要异步，所以需要另外一个协程处理，所以需要退出信号（让我们向等待循环发出关闭信号）</span></span><br><span class="line">    stopCh <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;  </span><br><span class="line">    <span class="comment">// 保证我们只发出一次退出信号</span></span><br><span class="line">    stopOnce sync.Once</span><br><span class="line">    <span class="comment">// 定时器，在没有任何数据操作时可以定时的唤醒处理协程（确保在激活前不超过 maxWait 时间）</span></span><br><span class="line">    heartbeat clock.Ticker </span><br><span class="line"></span><br><span class="line">    waitingForAddCh <span class="keyword">chan</span> *waitFor <span class="comment">// 所有延迟添加的元素封装成 waitFor 放到缓冲队列中</span></span><br><span class="line"></span><br><span class="line">    metrics           retryMetrics  <span class="comment">// 记录重试的次数</span></span><br><span class="line">    deprecatedMetrics retryMetrics</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// waitFor 保存要添加的数据和应该添加的时间</span></span><br><span class="line"><span class="keyword">type</span> waitFor <span class="keyword">struct</span> &#123;</span><br><span class="line">    data    t          <span class="comment">// 要添加的元素数据</span></span><br><span class="line">    readyAt time.Time  <span class="comment">// 应该被添加的时间点</span></span><br><span class="line">    index <span class="keyword">int</span>  <span class="comment">// 优先队列（heap）中的索引</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面关于延时队列的类型定义中，<code>waitFor</code>是保存延时的数据结构，在这个基础上还定义了一个 <code>waitForPriorityQueue</code>，用来实现 <code>waitFor</code> 元素的优先级队列，把需要延迟的元素形成了一个队列，按照元素的延时添加的时间（readyAt）从小到大排序。</p>
<p>通过实现 heap.Interface 接口来实现的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// go/src/container/heap/heap.go</span></span><br><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">    sort.Interface</span><br><span class="line">    Push(x <span class="keyword">interface</span>&#123;&#125;) <span class="comment">// add x as element Len()</span></span><br><span class="line">    Pop() <span class="keyword">interface</span>&#123;&#125;   <span class="comment">// remove and return element Len() - 1.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sort.Interface 定义如下所示：</span></span><br><span class="line"><span class="comment">// go/src/sort/sort.go</span></span><br><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// Len is the number of elements in the collection.</span></span><br><span class="line">    Len() <span class="keyword">int</span></span><br><span class="line">    <span class="comment">// Less reports whether the element with</span></span><br><span class="line">    <span class="comment">// index i should sort before the element with index j.</span></span><br><span class="line">    Less(i, j <span class="keyword">int</span>) <span class="keyword">bool</span></span><br><span class="line">    <span class="comment">// Swap swaps the elements with indexes i and j.</span></span><br><span class="line">    Swap(i, j <span class="keyword">int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只需要知道 <code>waitForPriorityQueue</code> 是一个有序的 slice，排序方式是按照时间从小到大排序的，根据 <code>heap.Interface</code> 的定义，我们需要实现 <code>Len</code>、<code>Less</code>、<code>Swap</code>、<code>Push</code>、<code>Pop</code> 这几个方法：</p>
<p><code>vendor/k8s.io/client-go/util/workqueue/delaying_queue.go</code>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> waitForPriorityQueue []*waitFor</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 Len 方法，获取队列长度</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq waitForPriorityQueue)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(pq)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 根据时间来比较排列顺序</span></span><br><span class="line"><span class="comment">// readyAt Time.time</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq waitForPriorityQueue)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> pq[i].readyAt.Before(pq[j].readyAt)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现交换第i和第j个元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq waitForPriorityQueue)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    pq[i], pq[j] = pq[j], pq[i]</span><br><span class="line">    pq[i].index = i  <span class="comment">// 由于heap中没有索引，所以需要自己记录，waitFor中就定义了index索引</span></span><br><span class="line">    pq[j].index = j</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加元素到队列中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq *waitForPriorityQueue)</span> <span class="title">Push</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(*pq)</span><br><span class="line">    item := x.(*waitFor)</span><br><span class="line">    item.index = n  <span class="comment">// 记录索引值</span></span><br><span class="line">    *pq = <span class="built_in">append</span>(*pq, item)  <span class="comment">// 放到slice尾部</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从队列中弹出最后一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq *waitForPriorityQueue)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(*pq)</span><br><span class="line">    item := (*pq)[n<span class="number">-1</span>]</span><br><span class="line">    item.index = <span class="number">-1</span></span><br><span class="line">    *pq = (*pq)[<span class="number">0</span>:(n - <span class="number">1</span>)]  <span class="comment">// 去掉最后一个元素</span></span><br><span class="line">    <span class="keyword">return</span> item</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回第一个元素，注意并没有移走</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq waitForPriorityQueue)</span> <span class="title">Peek</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">    <span class="keyword">return</span> pq[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为延时队列利用 <code>waitForPriorityQueue</code> 队列管理所有延时添加的元素，所有的元素在 <code>waitForPriorityQueue</code> 中按照时间从小到大排序，这样延时队列的处理就会方便很多了。</p>
<p>来看下延时队列的实现，由于延时队列包装了通用队列，只需要查看新增的实现延时的函数即可：</p>
<p><code>vendor/k8s.io/client-go/util/workqueue/delaying_queue.go</code>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AddAfter 在给定的延时时间后添加元素到 workqueue 队列上</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *delayingType)</span> <span class="title">AddAfter</span><span class="params">(item <span class="keyword">interface</span>&#123;&#125;, duration time.Duration)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 如果已经关闭则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> q.ShuttingDown() &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录 metrics</span></span><br><span class="line">    q.metrics.retry()</span><br><span class="line">    q.deprecatedMetrics.retry()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不需要延迟，那就直接添加</span></span><br><span class="line">    <span class="keyword">if</span> duration &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        q.Add(item)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把元素封装成 waitFor 传入 channel，由于 select 没有default，所以被阻塞</span></span><br><span class="line">    <span class="comment">// 这里使用 stopCh，因为有阻塞的可能，所以用 stopCh 可以保证退出</span></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="comment">// 如果 ShutDown() 被调用，则退出</span></span><br><span class="line">    <span class="keyword">case</span> &lt;-q.stopCh:</span><br><span class="line">    <span class="keyword">case</span> q.waitingForAddCh &lt;- &amp;waitFor&#123;data: item, readyAt: q.clock.Now().Add(duration)&#125;:</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>AddAfter()</code> 就是简单把元素送到 channel 中，所以核心实现是从 channel 中获取数据的部分，如下所示：</p>
<p><code>vendor/k8s.io/client-go/util/workqueue/delaying_queue.go</code>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// waitingLoop 一直运行直到 workqueue 关闭了并检查要添加的元素列表</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *delayingType)</span> <span class="title">waitingLoop</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> utilruntime.HandleCrash()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当没有元素需要延时添加的时候利用这个变量实现长时间等待</span></span><br><span class="line">    never := <span class="built_in">make</span>(&lt;-<span class="keyword">chan</span> time.Time)</span><br><span class="line">    <span class="comment">// 初始化上面的有序队列</span></span><br><span class="line">    waitingForQueue := &amp;waitForPriorityQueue&#123;&#125;</span><br><span class="line">    heap.Init(waitingForQueue)</span><br><span class="line">    <span class="comment">// 这个map用来避免重复添加，如果重复添加则只更新时间即可</span></span><br><span class="line">    waitingEntryByData := <span class="keyword">map</span>[t]*waitFor&#123;&#125;</span><br><span class="line">    <span class="comment">// 开始死循环</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 队列关闭了则直接返回</span></span><br><span class="line">        <span class="keyword">if</span> q.Interface.ShuttingDown() &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取当前时间</span></span><br><span class="line">        now := q.clock.Now()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断有序队列中是否有元素</span></span><br><span class="line">        <span class="keyword">for</span> waitingForQueue.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 获得有序队列中的第一个元素</span></span><br><span class="line">            entry := waitingForQueue.Peek().(*waitFor)</span><br><span class="line">            <span class="comment">// 元素指定的时间是否过了？没有的话就跳出循环</span></span><br><span class="line">            <span class="keyword">if</span> entry.readyAt.After(now) &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果时间已经过了，那就从有序队列中拿出来放入通用队列中</span></span><br><span class="line">            <span class="comment">// 1.heap.Pop()将第一元素和最后一个元素交换，然后重新调用down下沉函数，保证是一个最小堆，然后调用 waitingForQueue.Pop() 弹出最后一个元素(实际上是第一个元素)</span></span><br><span class="line">            <span class="comment">// 2.从有序队列把元素弹出，同时要把元素从上面的避免重复的map中删除</span></span><br><span class="line">            entry = heap.Pop(waitingForQueue).(*waitFor)</span><br><span class="line">            q.Add(entry.data)</span><br><span class="line">            <span class="built_in">delete</span>(waitingEntryByData, entry.data)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果有序队列中没有元素，那就不用等待了，也就是永久等下去</span></span><br><span class="line">        <span class="comment">// 如果有序队列中有元素，那就用第一个元素指定的时间减去当前时间作为等待时间</span></span><br><span class="line">        <span class="comment">// 有序队列用时间排序，后面的元素需要等待的时间更长，所以先处理排序靠前的元素</span></span><br><span class="line">        nextReadyAt := never  </span><br><span class="line">        <span class="keyword">if</span> waitingForQueue.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">            entry := waitingForQueue.Peek().(*waitFor)</span><br><span class="line">            <span class="comment">// 元素执行的时间</span></span><br><span class="line">            nextReadyAt = q.clock.After(entry.readyAt.Sub(now))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 进入各种等待</span></span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="comment">// 退出信号</span></span><br><span class="line">        <span class="keyword">case</span> &lt;-q.stopCh:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="comment">// 定时器，ticker，每隔一段时间接收一个ticker，重新执行一次大循环，否则select就hang住了</span></span><br><span class="line">        <span class="keyword">case</span> &lt;-q.heartbeat.C():  <span class="comment">// 继续循环，将添加准备好的元素</span></span><br><span class="line">        <span class="comment">// 这个就是有序队列里面需要等待时间的信号，时间到就会有信号</span></span><br><span class="line">        <span class="keyword">case</span> &lt;-nextReadyAt:  <span class="comment">// 继续循环，将添加准备好的元素</span></span><br><span class="line">        <span class="comment">// 这里是从channel中获取元素，AddAfter()放入到channel中的元素</span></span><br><span class="line">        <span class="keyword">case</span> waitEntry := &lt;-q.waitingForAddCh:</span><br><span class="line">            <span class="comment">// 时间没有过就插入到有序队列中</span></span><br><span class="line">            <span class="keyword">if</span> waitEntry.readyAt.After(q.clock.Now()) &#123;</span><br><span class="line">                insert(waitingForQueue, waitingEntryByData, waitEntry)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果时间已经过了就直接放入通用队列</span></span><br><span class="line">                q.Add(waitEntry.data)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 由于队列中一次性可能会添加多个元素，在上面执行代码的期间可能 channel 数据积压了，如果全都从下一次循环来处理，需要消耗的时间太长了，所以这里再用一个循环来把当前 channel 中的数据全部取出来，不过需要注意这里用了 default，意味着 channel 中没有数据就会立刻停止</span></span><br><span class="line">            drained := <span class="literal">false</span></span><br><span class="line">            <span class="keyword">for</span> !drained &#123;</span><br><span class="line">                <span class="keyword">select</span> &#123;</span><br><span class="line">                <span class="keyword">case</span> waitEntry := &lt;-q.waitingForAddCh:</span><br><span class="line">                    <span class="keyword">if</span> waitEntry.readyAt.After(q.clock.Now()) &#123;</span><br><span class="line">                        insert(waitingForQueue, waitingEntryByData, waitEntry)</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        q.Add(waitEntry.data)</span><br><span class="line">                    &#125;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    drained = <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中插入元素到有序队列的实现如下所示：</p>
<p><code>vendor/k8s.io/client-go/util/workqueue/delaying_queue.go</code>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// insert 添加元素到优先级队列中，如果已经存在队列中了则更新 readyAt 时间</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insert</span><span class="params">(q *waitForPriorityQueue, knownEntries <span class="keyword">map</span>[t]*waitFor, entry *waitFor)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 如果元素已经存在，当时间会导致元素更快排队时则更新时间</span></span><br><span class="line">    existing, exists := knownEntries[entry.data]</span><br><span class="line">    <span class="keyword">if</span> exists &#123;</span><br><span class="line">        <span class="comment">// 执行时间更早了则更新 readyAt 时间</span></span><br><span class="line">        <span class="keyword">if</span> existing.readyAt.After(entry.readyAt) &#123;</span><br><span class="line">            existing.readyAt = entry.readyAt</span><br><span class="line">            heap.Fix(q, existing.index)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把元素放入有序队列中，并记录在map里面,这个map就是上面用于判断对象是否重复添加的map</span></span><br><span class="line">    <span class="comment">// 注意，这里面调用的是 heap.Push，不是 waitForPriorityQueue.Push</span></span><br><span class="line">    heap.Push(q, entry)</span><br><span class="line">    knownEntries[entry.data] = entry</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于延迟队列而言，最主要的字段是 waitingForAddCh，默认大小为 1000，通过 AddAfter 方法插入元素时，是非阻塞状态的，只有当插入的元素大于或者等于1000，延迟队列处于阻塞状态。waitingForAddCh 字段中的数据通过 goroutine 运行的 waitingLoop 函数持久化运行。一个延迟队列的流程如下：</p>
<ol>
<li>将元素1放入 waitingForAddCh 字段，通过 waitingLoop 函数消费元数据；</li>
<li>元素延迟时间还未到达当前时间时，说明还需要延迟将元素插入 FIFO 的时间，将元素放入优先队列 waitForPriorityQueue 中，元素的延迟时间到达当前时间时，将队列插入 FIFO 中；</li>
<li>还会遍历优先队列 waitForPriorityQueue 的元素，按照上述逻辑验证时间。</li>
</ol>
<h3 id="限速队列"><a href="#限速队列" class="headerlink" title="限速队列"></a>限速队列</h3><p>RateLimitingInterface，基于 FIFO 和 延迟队列接口封装，增加了 AddRateLimit，Forget，NumRequeues 等方法。限速队列重点不在于 RateLimitingInterface 接口，而在于提供的4种限速算法接口 RateLimiter。</p>
<p><code>vendor/k8s.io/client-go/util/workqueue/default_rate_limiters.go</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RateLimiter <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// When gets an item and gets to decide how long that item should wait</span></span><br><span class="line">	When(item <span class="keyword">interface</span>&#123;&#125;) time.Duration</span><br><span class="line">	<span class="comment">// Forget indicates that an item is finished being retried.  Doesn't matter whether its for perm failing</span></span><br><span class="line">	<span class="comment">// or for success, we'll stop tracking it</span></span><br><span class="line">	Forget(item <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">	<span class="comment">// NumRequeues returns back how many failures the item has had</span></span><br><span class="line">	NumRequeues(item <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在介绍四种算法前，需要了解一个概念，<strong>限速周期</strong>。一个限速周期指从执行 AddRateLimited 到执行完 Forget 方法之间的时间，如果该元素被 Forget 方法处理完，清空排队数。</p>
<p>四种限速算法如下：</p>
<ul>
<li>令牌桶算法（BucketRateLimiter）；</li>
<li>排队指数算法（ItemExponentialFailureRateLimiter）；</li>
<li>计数器算法（ItemFastSlowRateLimiter）；</li>
<li>混合模式（MaxOfRateLimiter），将多种限速算法混合使用。</li>
</ul>
<h4 id="BucketRateLimiter"><a href="#BucketRateLimiter" class="headerlink" title="BucketRateLimiter"></a>BucketRateLimiter</h4><p><code>BucketRateLimiter</code> 限速器是利用 <code>golang.org/x/time/rate</code> 包中的 <code>Limiter</code> 来实现稳定速率(<code>qps</code>)的限速器。令牌筒内部实现了一个存放 token 的“桶”，初始时“桶”是空的，token 以固定的速率往桶里填充，直到填满为止，多余的 token 会被丢弃。每个元素都会从令牌桶得到一个 token，只有得到 token 的元素才允许通过（accept），没有得到 token 的处于等待状态。图示如书本167页。</p>
<p>WorkQueue 在默认情况下会实例化令牌桶，代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rate.NewLimiter(rate.Limit(<span class="number">10</span>), <span class="number">100</span>)</span><br></pre></td></tr></table></figure>

<p>第一个参数表示每秒往桶放10个 token，第二个参数表示桶大小。假设一个限速队列插入了200个元素，通过 <code>r.Limiter.Reverse().Delay</code> 函数返回每个元素等待的时间（桶一开始是满的）。那么前100个元素（item0～item99）立刻被处理，后面元素的延迟时间 item100为100ms，item101为200ms……以此类推。</p>
<p>对应的结构体如下所示：</p>
<p><code>vendor/k8s.io/client-go/util/workqueue/default_rate_limiters.go</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据 workqueue ratelimiter API 调整标准 bucket</span></span><br><span class="line"><span class="keyword">type</span> BucketRateLimiter <span class="keyword">struct</span> &#123;</span><br><span class="line">    *rate.Limiter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该限速器对应的限速器实现如下所示：</p>
<p><code>vendor/k8s.io/client-go/util/workqueue/default_rate_limiters.go</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *BucketRateLimiter)</span> <span class="title">When</span><span class="params">(item <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">time</span>.<span class="title">Duration</span></span> &#123;</span><br><span class="line">    <span class="comment">// 获取延迟时间，该延迟会是一个相对固定的周期</span></span><br><span class="line">    <span class="keyword">return</span> r.Limiter.Reserve().Delay()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *BucketRateLimiter)</span> <span class="title">NumRequeues</span><span class="params">(item <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="comment">// 因为是固定频率的，所以就不存在重试了</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *BucketRateLimiter)</span> <span class="title">Forget</span><span class="params">(item <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ItemExponentialFailureRateLimiter"><a href="#ItemExponentialFailureRateLimiter" class="headerlink" title="ItemExponentialFailureRateLimiter"></a>ItemExponentialFailureRateLimiter</h4><p>ItemExponentialFailureRateLimiter 是比较常用的限速器，它将相同元素的排队数作为指数，排队数越大，速率限制呈指数级增长，最大不超过 maxDelay。元素的排队数统计是有限速周期的，前面说够，一个限速周期指从执行 AddRateLimited 到执行完 Forget 方法之间的时间，如果该元素被 Forget 方法处理完，清空排队数。</p>
<p>定义如下所示：</p>
<p><code>vendor/k8s.io/client-go/util/workqueue/default_rate_limiters.go</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// baseDelay*2^&lt;num-failures&gt; </span></span><br><span class="line"><span class="keyword">type</span> ItemExponentialFailureRateLimiter <span class="keyword">struct</span> &#123;</span><br><span class="line">    failuresLock sync.Mutex  <span class="comment">// 互斥锁</span></span><br><span class="line">    failures     <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]<span class="keyword">int</span>  <span class="comment">// 记录每个元素错误次数，每调用一次When累加一次</span></span><br><span class="line"></span><br><span class="line">    baseDelay time.Duration  <span class="comment">// 元素延迟基数</span></span><br><span class="line">    maxDelay  time.Duration  <span class="comment">// 元素最大的延迟时间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用来判断该结构体是否实现了 RateLimiter 接口，用作类型断言，如果没有实现接口 RateLimiter 则编译错误。</span></span><br><span class="line"><span class="comment">// 主要是为了触发 interface 编译器检查，看个人习惯，是否在这个地方进行检查</span></span><br><span class="line"><span class="keyword">var</span> _ RateLimiter = &amp;ItemExponentialFailureRateLimiter&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>该限速器对应的限速器实现如下所示：</p>
<p><code>vendor/k8s.io/client-go/util/workqueue/default_rate_limiters.go</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *ItemExponentialFailureRateLimiter)</span> <span class="title">When</span><span class="params">(item <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">time</span>.<span class="title">Duration</span></span> &#123;</span><br><span class="line">    r.failuresLock.Lock()</span><br><span class="line">    <span class="keyword">defer</span> r.failuresLock.Unlock()</span><br><span class="line">    <span class="comment">// 累加错误次数</span></span><br><span class="line">    exp := r.failures[item]</span><br><span class="line">    r.failures[item] = r.failures[item] + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过错误次数计算延迟时间，公式是2^i * baseDelay，按指数递增</span></span><br><span class="line">    backoff := <span class="keyword">float64</span>(r.baseDelay.Nanoseconds()) * math.Pow(<span class="number">2</span>, <span class="keyword">float64</span>(exp))</span><br><span class="line">    <span class="comment">// backoff 是有上限的，这样'calculated' 值不会溢出</span></span><br><span class="line">    <span class="keyword">if</span> backoff &gt; math.MaxInt64 &#123;</span><br><span class="line">        <span class="keyword">return</span> r.maxDelay</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算后的延迟值和最大延迟值二者取最小值</span></span><br><span class="line">    calculated := time.Duration(backoff)</span><br><span class="line">    <span class="keyword">if</span> calculated &gt; r.maxDelay &#123;</span><br><span class="line">        <span class="keyword">return</span> r.maxDelay</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> calculated</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *ItemExponentialFailureRateLimiter)</span> <span class="title">NumRequeues</span><span class="params">(item <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    r.failuresLock.Lock()</span><br><span class="line">    <span class="keyword">defer</span> r.failuresLock.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> r.failures[item]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *ItemExponentialFailureRateLimiter)</span> <span class="title">Forget</span><span class="params">(item <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    r.failuresLock.Lock()</span><br><span class="line">    <span class="keyword">defer</span> r.failuresLock.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">delete</span>(r.failures, item)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>ItemExponentialFailureRateLimiter</code> 限速器一般就是操作失败后又不断尝试，随着尝试次数的增加按照指数增加延迟时间，达到限速的目的。</p>
<p>如上代码所示，如果不存在相同元素，所有元素的延迟为 baseDelay；而在同一限速周期内，如果存在相同元素，那么相同元素的延迟时间指数级增长，最长不超过 maxDelay。</p>
<h4 id="ItemFastSlowRateLimiter"><a href="#ItemFastSlowRateLimiter" class="headerlink" title="ItemFastSlowRateLimiter"></a>ItemFastSlowRateLimiter</h4><p>最简单的一种限速算法，原理是：限制一段时间某元素内允许通过的元素数量，比如一分钟只允许100个同种，超过久不允许。在这个思想基础上扩展了 Fast 和 Slow 速率。</p>
<p><code>vendor/k8s.io/client-go/util/workqueue/default_rate_limiters.go</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以短延迟重试，达到阈值后开始用长延迟</span></span><br><span class="line"><span class="keyword">type</span> ItemFastSlowRateLimiter <span class="keyword">struct</span> &#123;</span><br><span class="line">    failuresLock sync.Mutex  <span class="comment">// 互斥锁</span></span><br><span class="line">    failures     <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]<span class="keyword">int</span>  <span class="comment">// 错误次数计数</span></span><br><span class="line"></span><br><span class="line">    maxFastAttempts <span class="keyword">int</span>  <span class="comment">// 错误尝试次数阈值</span></span><br><span class="line">    fastDelay       time.Duration  <span class="comment">// 短延迟时间</span></span><br><span class="line">    slowDelay       time.Duration  <span class="comment">// 长延迟时间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每当 AddRateLimited 方法插入新元素时，failures 会为该字段加1，fastDelay 和 slowDelay 用于定于 fast，slow 速率，核心代码如下：</p>
<p><code>vendor/k8s.io/client-go/util/workqueue/default_rate_limiters.go</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *ItemFastSlowRateLimiter)</span> <span class="title">When</span><span class="params">(item <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">time</span>.<span class="title">Duration</span></span> &#123;</span><br><span class="line">    r.failuresLock.Lock()</span><br><span class="line">    <span class="keyword">defer</span> r.failuresLock.Unlock()</span><br><span class="line">    <span class="comment">// 错误次数+1</span></span><br><span class="line">    r.failures[item] = r.failures[item] + <span class="number">1</span></span><br><span class="line">    <span class="comment">// 错误次数未超阈值，用短延迟</span></span><br><span class="line">    <span class="keyword">if</span> r.failures[item] &lt;= r.maxFastAttempts &#123;</span><br><span class="line">        <span class="keyword">return</span> r.fastDelay</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 错误次数超过阈值，用长延迟</span></span><br><span class="line">    <span class="keyword">return</span> r.slowDelay</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *ItemFastSlowRateLimiter)</span> <span class="title">NumRequeues</span><span class="params">(item <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    r.failuresLock.Lock()</span><br><span class="line">    <span class="keyword">defer</span> r.failuresLock.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> r.failures[item]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *ItemFastSlowRateLimiter)</span> <span class="title">Forget</span><span class="params">(item <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    r.failuresLock.Lock()</span><br><span class="line">    <span class="keyword">defer</span> r.failuresLock.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">delete</span>(r.failures, item)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="MaxOfRateLimiter"><a href="#MaxOfRateLimiter" class="headerlink" title="MaxOfRateLimiter"></a>MaxOfRateLimiter</h4><p>多种限速算法混用，返回其中的最大值：</p>
<p><code>vendor/k8s.io/client-go/util/workqueue/default_rate_limiters.go</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MaxOfRateLimiter <span class="keyword">struct</span> &#123;</span><br><span class="line">    limiters []RateLimiter  <span class="comment">// 限速器slice</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>vendor/k8s.io/client-go/util/workqueue/default_rate_limiters.go</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *MaxOfRateLimiter)</span> <span class="title">When</span><span class="params">(item <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">time</span>.<span class="title">Duration</span></span> &#123;</span><br><span class="line">    ret := time.Duration(<span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 获取所有限速器里面时间最大的</span></span><br><span class="line">    <span class="keyword">for</span> _, limiter := <span class="keyword">range</span> r.limiters &#123;</span><br><span class="line">        curr := limiter.When(item)</span><br><span class="line">        <span class="keyword">if</span> curr &gt; ret &#123;</span><br><span class="line">            ret = curr</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *MaxOfRateLimiter)</span> <span class="title">NumRequeues</span><span class="params">(item <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    ret := <span class="number">0</span></span><br><span class="line">    <span class="comment">// 同样获取所有限速器里面最大的 Requeue 次数</span></span><br><span class="line">    <span class="keyword">for</span> _, limiter := <span class="keyword">range</span> r.limiters &#123;</span><br><span class="line">        curr := limiter.NumRequeues(item)</span><br><span class="line">        <span class="keyword">if</span> curr &gt; ret &#123;</span><br><span class="line">            ret = curr</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *MaxOfRateLimiter)</span> <span class="title">Forget</span><span class="params">(item <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 调用所有的限速器的 Forget 方法</span></span><br><span class="line">    <span class="keyword">for</span> _, limiter := <span class="keyword">range</span> r.limiters &#123;</span><br><span class="line">        limiter.Forget(item)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="限速队列实现"><a href="#限速队列实现" class="headerlink" title="限速队列实现"></a>限速队列实现</h4><p>限速队列的接口定义如下所示：</p>
<p><code>vendor/k8s.io/client-go/util/workqueue/rate_limiting_queue.go</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RateLimitingInterface 将限速的元素添加到队列中的一个接口</span></span><br><span class="line"><span class="keyword">type</span> RateLimitingInterface <span class="keyword">interface</span> &#123;</span><br><span class="line">    DelayingInterface  <span class="comment">// 继承了延时队列</span></span><br><span class="line"></span><br><span class="line">    AddRateLimited(item <span class="keyword">interface</span>&#123;&#125;)  <span class="comment">// 按照限速方式添加元素</span></span><br><span class="line"></span><br><span class="line">    Forget(item <span class="keyword">interface</span>&#123;&#125;)  <span class="comment">// 表示已经重试某元素，丢弃指定的元素，该操作只会清除`rateLimter`，仍然必须在队列上调用 Done</span></span><br><span class="line"></span><br><span class="line">    NumRequeues(item <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">int</span>  <span class="comment">// 元素放入队列的次数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewRateLimitingQueue 构造一个带有限速能力的工作队列，要记住调用 Forget！否则可能会一直跟踪失败下去。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRateLimitingQueue</span><span class="params">(rateLimiter RateLimiter)</span> <span class="title">RateLimitingInterface</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;rateLimitingType&#123;</span><br><span class="line">        DelayingInterface: NewDelayingQueue(),  <span class="comment">// 构造一个延迟队列</span></span><br><span class="line">        rateLimiter:       rateLimiter,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该限速器接口对应的实现如下所示：</p>
<p><code>vendor/k8s.io/client-go/util/workqueue/rate_limiting_queue.go</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rateLimitingType wraps an Interface and provides rateLimited re-enquing</span></span><br><span class="line"><span class="keyword">type</span> rateLimitingType <span class="keyword">struct</span> &#123;</span><br><span class="line">    DelayingInterface  <span class="comment">// 继承延迟队列</span></span><br><span class="line"></span><br><span class="line">    rateLimiter RateLimiter  <span class="comment">// 添加一个限速器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *rateLimitingType)</span> <span class="title">AddRateLimited</span><span class="params">(item <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 通过限速器获取元素延时时间，然后加入到延迟队列中去</span></span><br><span class="line">    q.DelayingInterface.AddAfter(item, q.rateLimiter.When(item))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *rateLimitingType)</span> <span class="title">NumRequeues</span><span class="params">(item <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="comment">// 获取限速器中元素加上队列的次数</span></span><br><span class="line">    <span class="keyword">return</span> q.rateLimiter.NumRequeues(item)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *rateLimitingType)</span> <span class="title">Forget</span><span class="params">(item <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 已经重试某元素，丢弃指定的元素</span></span><br><span class="line">    q.rateLimiter.Forget(item)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


        
        <br />
        <div id="comment-container">
        </div>
        <div id="disqus_thread"></div>

        <div id="lv-container">
        </div>

    </div>
</div>

    </div>
</div>


<footer class="footer">
    <ul class="list-inline text-center">
        
        

        

        

        
        <li>
            <a target="_blank"  href="https://github.com/linxuyalun">
                            <span class="fa-stack fa-lg">
                                <i class="iconfont icon-github"></i>
                            </span>
            </a>
        </li>
        

        
        <li>
            <a target="_blank"  href="https://www.linkedin.com/in/亚伦-林许-b06aa5164">
                            <span class="fa-stack fa-lg">
                                <i class="iconfont icon-linkedin"></i>
                            </span>
            </a>
        </li>
        

    </ul>
    
    <p>
        <span>/</span>
        
        <span><a href="https://blog.thrimbda.com/" target="_blank" rel="noopener">Thrimbda&#39;s blog</a></span>
        <span>/</span>
        
        <span><a href="https://vanderchen.github.io/" target="_blank" rel="noopener">VanderChen&#39;s Dev Blog</a></span>
        <span>/</span>
        
    </p>
    
    <p>
        <span id="busuanzi_container_site_pv">
            <span id="busuanzi_value_site_pv"></span>PV
        </span>
        <span id="busuanzi_container_site_uv">
            <span id="busuanzi_value_site_uv"></span>UV
        </span>
        Created By <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>  Theme <a href="https://github.com/aircloud/hexo-theme-aircloud" target="_blank" rel="noopener">AirCloud</a></p>
</footer>




</body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = ""
    window.hexo_root = "/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>

<script src="/js/index.js"></script>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




</html>
